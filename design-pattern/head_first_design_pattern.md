# 设计原则

当设计维护时，为了复用目的使用基础并不完美。

找出应用中会变化的部分取出来封装，让其他部分不会受到影响。这样代码变化引起的不经意后果变少，系统变得更有弹性。

针对接口编程，而不是针对实现编程。针对接口编程的关键在于多态，利用多态，可在执行时根据实际状况执行到真正的行为，不会被绑死在超类的行为上。更明确点，就是变量的类型应是超类型。

多用组合和委托，少用继承。继承设计子类的行为，是在编译时静态决定的，所有子类会继承到相同的行为。使用组合建立系统有很大的弹性，不仅可将算法族封装成类，更可以在运行时动态地改变行为。

为了交互对象之间的松耦合设计而努力。松耦合把对象之间的互相依赖降到了最低，能应对变化。

类应该对扩展开放，对修改关闭。目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。这样设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求。选择需要被扩展的代码部分时要小心，每个地方都使用开放-关闭原则是一种浪费，会导致代码过于复杂难以理解。

依赖倒置原则，要依赖抽象，不要依赖具体类。不能让高层组件依赖低层组件，二者都应该依赖于抽象。高层组件是由其他低层组件定义其行为的类。避免违反依赖倒置原则：变量不可以持有具体类的引用，使用 `new`
会有具体类的引用，用工厂避开这种做法；不要让类派生自具体类；不要覆盖基类中已实现的方法。

最少知识原则，要减少对象之间的交互，只留下几个密友。设计一个系统时，不管是任何对象，都要注意它所交互的类有哪些，并注意它和这些类是如何交互的。不要让太多累耦合在一起，以免修改系统的一部分会影响到其他部分。如果许多类之间互相依赖，系统会变成一个易碎的系统，需要花许多成本维护，不易被理解。该原则能减少维护成本，但是会产生更多包装类，导致复杂度增加。

就任何对象而言，我们只调用以下范围的对象：该对象本身；被当作方法参数传递进来的对象；此方法创建的对象；对象的组件。如果对象是调用其他方法的返回结果，不要调用该对象的方法。

好莱坞原则，别调用我们，我们会调用你。提供一种防止依赖腐败的方法，当高层组件依赖低层组件，而低层组件又依赖高层组件，而高层组件又依赖边侧组件，而边侧组件又依赖低层组件时，依赖腐败就发生了。好莱坞原则下，允许低层组件将自己挂钩到系统上，但高层组件会决定何时和怎样使用这些低层组件。低层组件可参与计算，但低层组件绝对不可以直接使用高层组件。创建一个有弹性的设计，允许低层结构能互相放做，而又防止其他类太过依赖它们。将决策权放在高层模块中，以便决定如何及何时调用低层模块。

一个类应该只有一个引起变化的原因。类的每个责任都有改变的潜在区域，超过一个责任，意味着超过一个改变的区域。尽量让每个类保持单一责任。如果一个类具有两个改变的原因，会使将来该类的变化机率上升，真的改变时，设计中同时有两个方面会受到影响。该原则告诉我们将一个责任只指派给一个类。当一个模块或一个类被设计成只支持一组相关功能时，它具有高内聚。

# 设计模式

模式是在某情境下，针对某问题的某种解决方案。处于某个情景下，面对要达到的目标被一些约束影响着的问题，能基于某个设计，克服这些约束达到该目标。

模式必须应用于一个重复出现的问题。

根据模式的目标划分类目：创建型模式涉及到将对象实例化，这类模式提供一个方法，将客户从所需实例化的对象中解耦；行为型模式，涉及到类和对象如何交互及分配指责；结构型模式，把类或对象组合到更大的结构中。

根据处理的目标划分类目：类模式描述类之间的关系如何通过继承定义，是在编译时建立的；对象模式描述对象间的关系，利用组合定义，通常在运行时建立，更动态、更有弹性。

使用设计模式时，要保持简单。模式是解决一再发生的问题的通用解决方案，使用模式，需要考虑模式对设计中其他部分造成的影响。找出设计中会改变的区域，这通常是需要模式的迹象。

模式可能带来复杂性，如果没必要，我们绝不需要这样的复杂性。

## 策略模式

定义了算法族，分别封装起来，让它们之间可互相替换，让算法的变化独立于使用算法的客户。

## 观察者模式

主题对象管理某些数据，当主题内的数据改变就会通知观察者，观察者订阅主题以便在主题数据改变时能收到更新。一旦数据改变，新的数据会以某种形式送到观察者手上。

观察者模式定义了对象间的一对多依赖，这样当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。主题是真正拥有数据的，观察者是主题的依赖者，在数据变化时更新，这样相比让许多对象控制同一份数据，可得到更干净的设计。

观察者模式让主题和观察者之间松耦合，当两个对象之间松耦合，它们依然可以交互，但不清楚彼此的细节。主题只知道观察者实现了某个接口，不知道观察者的细节。任何时候都可以新增观察者，因为主题唯一依赖的是实现观察者接口的对象列表。

此模式有推和拉两种方式。有多个观察者时，不可依赖特定的通知次序。

## 装饰者模式

装饰者和被装饰者对象有相同的超类型，可用一个或多个装饰者包装一个对象，在任何需要被包装对象的场合，可用装饰过的对象代替它。装饰者可以在所委托被装饰者的行为前后，加上自己的行为达到目的。对象可在任何时候被修饰，可在运行时动态不限量地修饰对象。

装饰者模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

每个装饰者有一个实例变量保存被装饰者的引用，装饰者可以加上新方法扩展功能。

装饰者利用继承达到类型匹配，而不是利用继承获得新的行为，行为来自装饰者与被装饰者，或与其他装饰者的组合关系。因装饰者可取代被装饰者，所有二者需要有相同的接口。将装饰者与被装饰者组合，就是在加入新行为，所获得的新行为，是由组合对象得来的。如果用继承，类的行为只能在编译时静态决定，利用组合，可在运行时把装饰者混合使用。即可在任何时候，实现新的装饰者增加新的行为，如果依赖继承，每次需要新行为时要修改代码。

使用装饰者模式，必须管理更多的对象。通常装饰者用类似工厂或生成器这样的模式创建的。

装饰者模式的缺点：常常造成设计中有大量小类，数量太多，给使用者造成困扰。

## 工厂模式

工厂处理创建对象的细节。

静态工厂，使用静态方法定义，不需要使用创建对象的方法来实例化对象。缺点是不能通过继承改变创建方法的行为。

工厂方法模式，定义了一个创建对象的接口，由子类决定要实例化的类，工厂方法让类把实例化推迟到子类。

抽象工厂模式，提供一个接口用于创建相关或依赖对象的家族，而不需要明确指定具体类。允许客户使用抽象接口创建一组相关的产品，而不需要知道实际的具体产品是什么，将客户从具体的产品中解耦。

抽象工厂的方法常以工厂方法的方式实现，抽象工厂的任务是定义一个负责创建一组产品的接口，该接口的每个方法都负责创建一个具体产品，使用实现抽象工厂的子类提供这些具体的做法。

相比于工厂方法，抽象工厂方法定义的是一组产品的创建，实际工厂的实现方法用的还是工厂方法。

所有的工厂都用来封装对象的创建。工厂方法使用继承，把对象的创建委托给子类，子类实现工厂方法创建对象。抽象工厂使用对象组合，对象的创建被实现在工厂接口暴露出来的方法中。所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合。工厂方法允许类将实例化延迟到子类进程。抽象工厂创建相关对象的家族，不需要依赖具体的类。

## 单例模式

确保一个类只有一个实例，并提供一个全局访问点。单例类构造器是私有的，不能用私有构造器扩展类，不能继承。

## 命令模式

把方法调用封装起来。将动作的请求者从动作的执行者对象中解耦，把请求封装成一个特定对象。允许发出请求的对象和接受与执行请求的对象分隔开。

客户创建命令对象，命令对象包含接收者的一组动作。动作和接收者在命令对象中被绑在一起，命令对象提供方法 `execute()`
封装动作。客户在调用者对象上用 `setCommand()` 传入命令对象。命令被加载到调用者后，可使用并丢弃，或保留下来使用多次。

将请求封装成对象，以便使用不同的请求、队列或日志来参数化其他对象，支持可撤销的操作。

一个命令对象通过在特定接收者上绑定一组动作封装一个请求。命令对象将动作和接收者包装进对象，该对象只暴露 `execute()`
方法，方法被调用时，接收者会进行这些动作。其他对象不关注哪个接收者进行哪些动作。

`NoCommand` 对象是一个空对象，当不想返回一个有意义的对象时，空对象就很有用，客户可将处理 `null` 的责任转移给空对象。

建议把命令接收执行者提取出来，命令对象只调用接收者的行为，这样可实现最大程度的解耦，接收者可作为参数传递给命令对象。

要实现撤销，可用一个堆栈记录过去操作的每一个命令。

命令可将运算块打包（一个接收者和一组动作）传递，像一个一般的对象。该特性可衍生一些应用，日程安排、线程池、工作队列、日志。

命令模式将发出请求的对象和执行请求的对象解耦。在被解耦的两者之间通过命令对象沟通，命令对象封装了接收者和一组动作。宏命令是命令的一种简单延伸，允许调用多个命令。

## 适配器模式

客户通过目标接口调用适配器的方法对适配器发出请求。适配器实现了目标接口，持有被适配者的实例，使用被适配者接口转换请求。客户接收到调用的结果，并未察觉是适配器在起转换作用。

实现一个适配器需要的工作和目标接口大小成正比。如果不用适配器，必须改写客户端代码调用新的接口，提供一个适配器类，将所有改变封装进一个类，是更好的做法。

如果新旧接口都需要使用，可创建一个双向的适配器，支持两边的接口。

适配器模式将一个类的接口，转换成客户期望的另一个接口，让原本接口不兼容的类可以合作无间。

该模式通过创建适配器进行接口转换，让不兼容的接口变成兼容。这可以让客户从实现的接口解耦。如果在一段时间后，想要改变接口，适配器可将改变的部分封装起来，客户不必为了应对不同的接口每次修改。

适配器模式使用对象组合，以修改的接口包装被适配者。被适配者的任何子类，都可搭配适配器使用。把客户和接口绑定起来，而不是和实现绑定起来。

适配器的好处是，允许客户使用新的库和子集合，无须改变任何代码。

装饰者模式，不改变接口，加入责任；适配器模式，将一个接口转成另一个接口；外观模式，让接口更简单。

## 外观模式

实现一个提供更合理的接口的外观类，将一个复杂子系统变得更容易使用。只是提供更直接的操作，并未将原来的子系统阻隔起来，需要子系统类更高层的功能，还可以使用。

不只是简化了接口，也将客户从组件的子系统解耦，当对子系统的使用变化，只需要修改外观代码，不需要修改客户端。

外观模式和适配器模式都可以包装许多类，只是外观的意图是简化接口。

外观模式提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。

## 模版方法模式

封装算法块，让子类在任何时候都可以将自己挂接进运算里。

模板方法定义了一个算法步骤，允许子类为一个或多个步骤提供实现。模板方法模式在一个方法中定义一个算法骨架，将一些步骤延迟到子类中，使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。用来创建一个算法模板，模板就是一个方法，这个方法将算法定义成一组步骤，其中的任何步骤都可以是抽象的，由子类负责实现。

钩子可以让子类实现算法中可选的部分，让子类有机会对模板方法中某些即将发生的步骤作出反应。

模板方法定义了算法步骤，把这些步骤实现延迟到子类，为我们提供了一种代码复用的重要技巧。和策略模式一样，都是封装算法，区别是模板方法能减少重复代码。

## 迭代器模式

提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。迭代器模式把在元素之间游走的责任交给迭代器，而不是聚合对象。这不仅让聚合的接口和实现变得更简洁，也可以让聚合更专注在它所应该专注的事情上，而不必去理会遍历的事情。

## 组合模式

允许将对象组合成树形结构来表现整体/部分层次结构，树里包含了组合及个别的对象。组合能让客户以一致的方式处理个别对象以及对象组合，大多数情况可忽略对象组合和个别对象间的差别。

组合模式以单一责任设计原则换取透明性。通过让组件的接口同时包含一些管理子节点和叶子结点的操作，客户可将组合和叶节点一视同仁，一个元素究竟是组合还是叶节点，对客户是透明的。

树中的元素同时有两种类型的操作，客户有机会对一个元素做不恰当的操作，失去了一些安全性。如果将责任区分开放到不同的接口，设计上安全，但失去了透明性，客户需要用条件语句区分不同类型的节点。

当有数个对象的集合，它们彼此间有整体/部分关系，若想用一致的方法处理这些对象，用组合模式。一致的方法是组合和叶节点间有共同的方法可以调用，这意味着有些对象具备一些没有意义的方法调用，可让这样的方法不做事。客户不用关心操作的是组合对象还是叶节点对象，不用写一堆条件语句保证方法调用正确。

## 状态模式

通过改变对象内部的状态帮助对象控制自己的行为。

状态模式可将每个状态的行为局部化到自己的类中；将容易产生问题的条件语句删除，方便日后维护；让每个状态对修改关闭，对使用状态的类对扩展开放，方便加入新的状态类。

状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。将状态封装成独立的类，将动作委托到代表当前状态的对象，行为会随着内部状态改变，将需要做的改变局部化。

和策略模式很像，状态模式状态在对象中游走，使用对象的客户对状态浑然不知，是不用放置许多条件语句的替代方案。策略模式是客户主动指定要使用的策略对象，是除继承外的一种弹性替代方案。

状态模式会增加很多状态类，但获取到弹性是值得的，真正重要的是暴露给客户的类数目。

## 代理模式

代理要做的是控制和管理访问。代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。使用代理模式创建代表对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象。

远程代理控制访问远程对象；虚拟代理控制访问创建开销大的资源；保护代理基于权限控制对象资源的访问；动态代理在运行时才被创建，根据需要从传入的接口集创建。

代理模式将访问控制与业务逻辑分离，可灵活添加额外的功能或控制，可智能处理访问请求，如延迟加载、缓存。

代理和真实主题共同实现了抽象主题，代理持有对真实主题的引用。

装饰者模式为对象加上行为，而代理是控制访问。

## MVC模式

`MVC` 是一种复合模式，由数个设计模式结合起来。模型-视图-控制器，视图呈现模型，从模型取得需要显示的状态，将用户的输入传给控制器；控制器解读输入，传给模型；模型持有所有数据状态，改变时通知视图。

模型利用观察者让控制器和视图随最新状态改变而更新。视图和控制器实现策略模式，希望有不同行为可换控制器。视图内部使用组合模式管理窗口、按钮和其他组件。

## 建造者模式

将一个复杂对象的创建过程封装起来，将创建步骤和表示方式分离，从而可创建具有不同表示形式的对象。相比于工厂模式，更注重于属性赋值的顺序，如 `StringBuilder`。

使用场景：不同组件的装配顺序不同会产生不同的作用，初始化对象很复杂，有多个构造方法，有很多参数，且都有默认值。

## 解释器模式

将每一种语法规则表示成一个类，方便实现语言。语法由许多类表示，可轻易改变或扩展语言。在类结构中加入新方法，可以在解释的同时增加新的行为。当某个特定类型的问题频繁出现，并可通过一种简单的语言表达这些问题的实例时，使用解释器模式。

实现方法：定义文法，明确语言的终结符和非终结符；构建语法树，根据语言的句子构建对应的语法树结构；创建环境类，包含解释过程中需要的全局信息。

抽象表达式定义了解释器的抽象接口，声明了解释操作的方法；终结符表达式实现了抽象表达式接口的终结符表达式类，用于表示语言中的终结符，实现对应的解释操作；非终结符表达式，实现了抽象表达式接口的非终结符表达式类，用于表示语言中的非终结符操作，实现对应的解释操作；上下文，包含解释器之外的全局信息，在解释过程中使用，通常存储变量的值。

## 原型模式

用于创建重复对象，同时保证性能。实现一个原型接口，用于创建当前对象的克隆。当直接创建对象代价比较大，采用该模式。

## 蝇量模式

让某个类的一个实例提供许多虚拟实例。只用一个实例和一个客户对象维护所有状态。

可以减少运行时对象实例的个数，节省内存，将许多虚拟对象的状态集中管理。当一个类有许多实例，这些实例能被同一方法控制时，使用该模式。

通过共享对象减少创建大量相似对象时的内存消耗，避免因创建大量对象导致的内存溢出。

## 桥接模式

把抽象和实现解耦，使二者可独立变化。用桥接接口提供实现，当一个类存在两个独立变化的维度，这两个维度都需要扩展时，使用桥接模式。

把实现和抽象放在两个不同的类层次中而使它们可以独立改变，这两个层次之间的关系叫桥接。抽象和实现可独立扩展，不会互相影响。当需要用不同的方式改变接口和实现时，用桥接模式。

## 中介者模式

可集中相关对象之间复杂的沟通和控制方式。定义一个中介对象封装对象间的交互，使对象间不需要显式相互引用，可独立改变它们之间的交互。解决对象间复杂的一对多关联问题，避免对象间高度耦合，简化系统结构。

将多个对象间的一对多关系转换为一对一关系，对象只知道中介者，不需要知道其他对象。

中介者定义接口与同事对象通信，管理同事对象间的关系。同事对象与中介者通信，通常包含一个发送消息的方法及一个接收消息的方法。

## 备忘录模式

保存一个对象的某个状态，以便在适当的时候恢复对象，允许保存一个对象的内部状态，以便将来可以恢复该状态，实现撤销和回滚操作。备忘录类，用于存储封装对象状态。创建发起人，负责创建备忘录，根据需要恢复状态。负责人，保存备忘录对象，将备忘录传递给其他对象。应用于游戏存档、数据库事务管理。

## 责任链模式

通过责任链模式，可以为某个请求创建一个对象链。每个对象依序检查此请求，对其进行处理，传给链中的下一个对象。链中的每个对象扮演处理器，有一个后继对象。如果可以处理请求，就进行处理，否则把请求转发给后继者。

将请求的发送者和接受者解耦。可以简化对象，不需要知道链的结构。改变链中的成员或调动它们的次序，允许动态新增删除责任。处理请求时，如果有多个潜在的处理者，考虑使用该模式。

## 访问者模式

将数据结构与在该数据结构上的执行操作分离，使添加新的操作更容易，不需要修改数据结构本身。解决在稳定数据结构和易变操作间的耦合问题，使操作可以独立于数据结构变化。

需要对一个数据结构中的对象执行多种不同且不相关的操作时使用。

访问者接口，声明一系列访问方法，一个访问方法对应数据结构中的一个元素类；元素接口，声明一个接受访问者的方法。

对象结构稳定，需要在其上定义多种新操作时，考虑该模式。
