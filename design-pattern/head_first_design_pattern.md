# 设计原则

当设计维护时，为了复用目的使用基础并不完美。

找出应用中会变化的部分取出来封装，让其他部分不会受到影响。这样代码变化引起的不经意后果变少，系统变得更有弹性。

针对接口编程，而不是针对实现编程。针对接口编程的关键在于多态，利用多态，可在执行时根据实际状况执行到真正的行为，不会被绑死在超类的行为上。更明确点，就是变量的类型应是超类型。

多用组合和委托，少用继承。继承设计子类的行为，是在编译时静态决定的，所有子类会继承到相同的行为。使用组合建立系统有很大的弹性，不仅可将算法族封装成类，更可以在运行时动态地改变行为。

为了交互对象之间的松耦合设计而努力。松耦合把对象之间的互相依赖降到了最低，能应对变化。

类应该对扩展开放，对修改关闭。目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。这样设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求。选择需要被扩展的代码部分时要小心，每个地方都使用开放-关闭原则是一种浪费，会导致代码过于复杂难以理解。

# 设计模式

## 策略模式

定义了算法族，分别封装起来，让它们之间可互相替换，让算法的变化独立于使用算法的客户。

## 观察者模式

主题对象管理某些数据，当主题内的数据改变就会通知观察者，观察者订阅主题以便在主题数据改变时能收到更新。一旦数据改变，新的数据会以某种形式送到观察者手上。

观察者模式定义了对象间的一对多依赖，这样当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。主题是真正拥有数据的，观察者是主题的依赖者，在数据变化时更新，这样相比让许多对象控制同一份数据，可得到更干净的设计。

观察者模式让主题和观察者之间松耦合，当两个对象之间松耦合，它们依然可以交互，但不清楚彼此的细节。主题只知道观察者实现了某个接口，不知道观察者的细节。任何时候都可以新增观察者，因为主题唯一依赖的是实现观察者接口的对象列表。

此模式有推和拉两种方式。有多个观察者时，不可依赖特定的通知次序。

## 装饰者模式

装饰者和被装饰者对象有相同的超类型，可用一个或多个装饰者包装一个对象，在任何需要被包装对象的场合，可用装饰过的对象代替它。装饰者可以在所委托被装饰者的行为前后，加上自己的行为达到目的。对象可在任何时候被修饰，可在运行时动态不限量地修饰对象。

装饰者模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

每个装饰者有一个实例变量保存被装饰者的引用，装饰者可以加上新方法扩展功能。

装饰者利用继承达到类型匹配，而不是利用继承获得新的行为，行为来自装饰者与被装饰者，或与其他装饰者的组合关系。因装饰者可取代被装饰者，所有二者需要有相同的接口。将装饰者与被装饰者组合，就是在加入新行为，所获得的新行为，是由组合对象得来的。如果用继承，类的行为只能在编译时静态决定，利用组合，可在运行时把装饰者混合使用。即可在任何时候，实现新的装饰者增加新的行为，如果依赖继承，每次需要新行为时要修改代码。
