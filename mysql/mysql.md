# 架构

存储引擎架构将查询处理及其他系统任务和数据的存储/摄取分离，分离的设计可根据需求选择数据存储方式。

最上层一般是连接处理、授权认证、安全。核心服务功能在第二层，包括查询解析、分析、优化、缓存及内置函数。跨存储引擎的功能都在该层：存储过程、触发器、视图。第三层是存储引擎，负责数据存储和提取。存储引擎不会解析 `SQL`，不会互相通信，只是响应上层请求。

每个客户端连接都会在服务器中拥有一个线程，该连接查询只在该线程执行。服务器会缓存线程，不需要为每个新连接创建。客户端连接到服务器，先基于用户名密码认证，连接成功后，验证客户端是否有执行某个特定查询的权限。

`MySQL` 解析查询，创建解析树后优化，包括重写查询、决定表的读取顺序、选合适的索引。优化器会请求存储引擎提供容量或某个操作的开销，及表数据统计信息。解析查询前，先查询缓存，能命中则直接返回结果。

解决并发控制可通过读锁和写锁。读锁是共享的，多个客户同一时刻读取同一资源互补干扰。写锁是排他的，一个写锁会阻塞其他的写锁和读锁。要提高并发性，尽量只锁定要修改的部分，锁定数据量越少，系统并发程度越高。但加锁也耗资源，包括获得锁、检查锁、释放锁。表锁锁定整张表，开销最小，可在服务层实现；行级锁客最大程度支持并发，只在存储引擎层实现。

事务是一组原子性的操作，事务内的语句，要么全部成功，要么全部失败。必须符合 `ACID`，原子性，事务被分成不可分割的最小单元；一致性，数据库总是从一个一致性状态转换到另一个一致性状态；隔离性，事务修改提交前对其他事务不可见；持久性，事务提交后将永久保存到数据库。

事务也会增加开销，这也发挥了存储引擎架构的优势，根据业务需要选择合适的存储引擎。

四种隔离级别：`READ UNCOMMITTED`，事务中的修改未提交，对其他事务也是可见的，读取未提交的数据为脏读；`READ COMMITTED`，事务执行过程可看见已提交事务的修改，事务执行两次相同查询可能不一样，又叫不可重复读；`REPEATABLE READ`，解决了脏读，无法解决幻读，即事务读取范围记录时，其他事务插入了新纪录，再次读取产生新的行；`SERIALIZABLE`，强制事务串行执行，避免了幻读，读取每行数据都加锁。

死锁即多个事务在同一资源上相互占用，请求锁定对方的资源，导致恶性循环。多个事务以不同顺序锁定资源或同时锁定同一资源是，会产生死锁。处理方法，回滚持有最少行级排他锁的事务。

事务日志可提高事务效率，存储引擎修改表时只需修改其内存拷贝，再把修改记录到事务日志中，不用每次都把修改的数据持久到磁盘。事务日志用追加的方式，为顺序IO。日志持久后，被修改的数据在后台慢慢回刷到磁盘。又称为预写日志，修改数据要写两次磁盘。

`MySQL` 默认用自动提交，若不显式开始一个事务，每个查询都被当作一个事务执行提交。服务器层不管理事务，事务由存储引擎实现。

二阶段锁定协议，事务执行过程随时可锁定，锁只有在提交或回滚时才会释放，所有锁在同一时刻释放，该方式为隐式锁定。

为提升并发性能，实现了 `MVCC`，避免加锁操作，通过保存数据在某时间点的快照实现。在每行记录后保存两个隐藏列，一个保存行创建时间，一个保存行删除时间，存储的值是系统版本号。每开始一个新事务，版本号自动递增，事务开始时刻的系统版本号为事务的版本号，用来和查询到的每行记录版本号比较。

`select`，只查找版本早于当前事务版本数据行；行删除版本未定义或大于当前事务版本，满足这两条，才返回为查询结果。`insert`，新插入的每一行保存当前系统版本号为行版本号。`delete`，为删除的每行保存当前系统版本号为删除标识。`update`，保存当前系统版本号为行版本号，保存当前系统版本号到原来的行作为行删除标识。

`MVCC` 只在 `REPEATABLE READ` 和 `READ COMMITTED` 两个隔离级别下工作。

文件系统中，每个数据库保存为数据目录下的一个子目录。创建表时，在子目录创建 `.frm` 文件保存表的定义。表定义在服务层统一管理。

`InnoDB`，默认事务型引擎，设计处理大量短期事务。用 `MVCC` 支持高并发，默认级别是 `REPEATABLE READ`，用间隙锁防止幻读，不仅锁定查询涉及的行，还对索引中的间隙锁定，防止幻行插入。基于聚簇索引建立，二级索引中必须包含主键列，主键列很大，所有索引都会很大。若表上的索引过多，主键要尽可能小。从磁盘读取数据用可预测性预读，建立自适应哈希索引加速读，插入缓冲区加速插入。支持热备份。

`MyISAM`，不支持事务和行级锁，崩溃后无法安全恢复。对整张表加锁。如果表创建导入数据后，不再进行修改操作，可用 `MyISAM` 压缩表，可极大减少磁盘空间占用，提升查询性能，支持索引，但索引是只读的。

# 数据类型优化

选择数据类型的原则：

- 选择不会超过范围的最小类型，节省磁盘内存；
- 先选简单的数据类型，需要更少的CPU周期；
- 尽量避免 `NULL`，查询包含可为 `NULL` 的列更难优化，列用更多的存储空间，要特殊处理。被索引时，每个索引记录要额外的字节。

为列选数据类型，先确定合适的大类型：数字、字符串、时间，再选具体类型。整数类型可选 `UNSIGNED`，表示不允许负数，可使上线提升一倍，但性能相同。`FLOAT` 和 `DOUBLE` 做近似计算，`DECIMAL` 支持精确计算。数据量大时用 `BIGINT` 代替 `DECIMAL`，将小数位数乘相应的倍数，避免存储不精确和计算代价高。

`VARCHAR` 和 `CHAR` 是两种主要的字符串类型。`VARCHAR` 存储可变长字符串，需要额外字节记录字符串长度，适合字符串列的最大长度比平均长度大很多，列的更新很少时使用，行增长时需要分裂页。`CHAR` 是定长的，对经常更新的数据不易产生碎片，适合存储很短或所有值接近同一长度的情况，检索时会去掉空格。

`BINARY` 和 `VARBINARY` 存储的是二进制字符串，存储的是字节码，比较效率相比字符更高。

`BLOB` 和 `TEXT` 用于存储大字符串，分别用二进制和字符存储。当作对象处理，值太大时会用外部存储区域存储，指针存储在行内。不能将 `BLOB` 和 `TEXT` 列全部长度的字符串索引，不能用这些索引消除排序。

枚举列可把一些不重复的字符串存储成一个预定义集合，存储枚举时很紧凑，会根据列表值的数量压缩到两个字节，将每个值在列表中的位置保存为整数，并按整数排序。枚举字符串列表是固定的，可能会改变的字符串不要用枚举。

日期类型有 `DATETIME` 和 `TIMESTAMP`。`TIMESTAMP` 存储空间更小，`DATETIME` 可保存更大范围的值。尽量使用 `TIMESTAMP`，空间效率更高。

为标识列选数据类型，选择和关联表中对应列一样的类型。混用不同数据类型可能导致性能问题，且应尽可能选更小的类型。整数通常是标识列最好的选择，很快且可以 `AUTO_INCREMENT`。对完全随机的字符串要注意，`MD5()`、`UUID()` 产生的字符串会任意分布到很大的空间，导致插入和查询很慢，导致缓存效果变差。存储 `UUID`，用 `UNHEX()` 转换为16字节的数字，存储到 `BINARY(16)` 的列，检索时再通过 `HEX()` 格式化。

存储 `IP` 地址可用无符号整数存储，用 `INET_ATON()` 和 `INET_NTOA` 转换。

设计要注意的点：存储引擎 `API` 要再服务器层和存储引擎层间通过行缓冲格式拷贝数据，在服务器层将缓冲内容解码成各个列，列过多时转换代价会很高。不要有太多的关联。防止过度使用枚举。

范式化的数据库，每个事实数据会只出现一次，反范式化的数据库，信息是冗余的可能存在多个地方。范式化更新操作更快，表通常更小，缺点是需要关联。反范式化可避免关联，单独的表可使用更有效的索引策略。

物化视图，预先计算存储在磁盘上的表，通过不同的策略刷新。物化视图要实现变更数据抓取，读取二进制日志解析相关行变更，帮助创建管理视图的存储过程，不需要通过查询原始数据更新视图。

`ALTER` 操作，有时会重建表，做一些类型的修改不需要重建表，只需要修改表的 `.frm` 文件。

为高效载入数据到 `MyISAM`，可先禁用索引、载入数据，然后重新启用索引，这样构建索引的数据延迟到数据完全载入后，使索引树碎片更少，但该方法对唯一索引无效。

# 索引

索引是存储引擎用于快速找到记录的一种数据结构。先在索引找到对应的值，根据索引记录找到对应的行。索引若包含多个列，列的顺序很重要，因为只能高效使用索引最左前缀列。

索引在存储引擎层实现。

