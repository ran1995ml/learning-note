# 架构

两层架构：`Server` 层和存储引擎层。`Server` 层建立连接、分析执行 `SQL`，包括连接器、查询缓存、解析器、优化器。存储引擎负责数据存储，不同存储引擎共用一个 `Server` 层。

基于 `TCP` 连接 `MySQL`，连接器验证用户名密码。若用户连接后没有执行过命令，该连接是空闲连接，超过时长连接器自动断开。

`MySQL` 使用长连接可能导致占用内存增多，解决方法：定期断开长连接，客户端主动重置连接释放内存。

`SQL` 是查询语句，先从查询缓存查找数据，查询缓存以 `key-value` 保存，`key` 是 `SQL` 语句，`value` 是查询结果。解析器：先解析词法，分析出关键字。分析语法构建语法树。预处理器：检查字段是否存在。优化器：将查询语句执行方案确定下来，根据成本确定索引。执行器：与存储引擎交互执行 `SQL`，每读到一条记录就发送给客户端。

`.frm` 文件存每个表的元数据信息，`.ibd` 文件存表数据和索引，又叫独占表空间文件。表空间结构：段、区、页、行。记录按行存储，以页为单位读入内存，每个页大小默认16K，行记录用数据页管理。表数据量大的时候，为索引分配空间按区，一个区包含多个页，保证构建 `B+` 树索引时同一层链表相邻的页物理位置相邻，便于使用顺序 `IO`。一个段包含多个区。

行格式，一条记录的存储结构，分为记录的额外信息和记录的真实数据。

记录额外信息：变长字段长度列表，占用的字节按列的顺序逆序存放，如 `varchar(n)`、`TEXT`、`BLOB`。记录头指针在记录的额外信息和真实数据之间，逆序便于读取。`NULL` 值列表记录有 `NULL` 值的列，字段设为 `NOT NULL` 可节省空间。记录头信息：`delete_mask`，数据是否被删除；`next_record`，下条记录位置；`record_type`：记录类型，0为普通记录，1为 `B+` 树非叶子节点记录，2位最小记录，3为最大记录。

记录真实数据：若未指定主键，会添加 `row_id`。`trx_id`，表示生成该数据的事务。`roll_pointer`，该记录的上一个版本。定义字段。

大对象 `TEXT`、`BLOB` 存储更多数据，单页存不了一条记录会发生行溢出，多的数据存到溢出页，真实数据出存储溢出页指针。

# 索引

`InnoDB` 根据表字段创建索引：主键作为聚簇索引；无主键，选第一个不包含 `NULL` 的列为聚簇索引；都没有，生成一个隐式自增id。主键之外的索引为辅助索引，又叫二级索引、非聚簇索引。

`InnoDB` 索引默认用 `B+` 树，多叉树，叶子节点放数据，非叶子节点只放索引，每个节点的数据按主键顺序存放。优势是层数低，可减少磁盘 `IO`。

二级索引叶子节点存放的是主键，再回表查询，若查询字段在二级索引中可查到就不用回表，该索引又称覆盖索引。

`B+` 树的优势：只有叶子节点存数据，通过分层降低每一层的搜索量。`B` 树非叶子节点也要存，二叉树深度高，磁盘 `IO` 次数更多。哈希做等值查询效率高，但不适合做范围查询。

主键索引：索引建在主键字段，一张表只有一个，索引列不能有空值。唯一索引：建在 `UNIQUE` 列上，一张表可有多个，允许有空值。普通索引：在普通列上创建。前缀索引：对字符类型的前几个字符建立索引，减少索引占用的空间。联合索引：多个字段组合成一个索引，要遵循最左匹配原则，按最左优先的方式匹配索引，否则索引会失效。

使用索引的前提是索引的键有序。最左匹配原则遇到范围查询会停止，范围查询的字段可用到联合索引，但之后的字段无法使用。`>=` 范围查询，等号可确定范围，使用到联合索引。建立联合索引，要把区分度大的字段排在前面，优化器发现某个值出现百分比很高时，会忽略索引扫描全表。

索引下推：联合索引遍历过程，若过滤条件有联合索引的字段，直接过滤不满足条件的记录，减少回表次数。

索引的缺点：占用物理内存，创建维护需要时间，降低表的增删改效率。索引的使用场景： `where` 或 `group by` 和 `order by` 常用字段，有唯一性限制。不适合场景：字段有大量重复数据，表数据太少，经常更新的字段。

索引优化：前缀索引优化，用于大字符串字段作为索引的场景，但是 `order by` 无法使用，不能做覆盖索引。覆盖索引优化，建立联合索引避免回表。主键索引最好递增，这样插入数据不需要移动其他数据，否则需要将数据从一个页面移动到另一个页面，产生页分裂，造成大量内存碎片。主键长度不要太大，这样二级索引的叶节点空间更小。索引最好设为 `NOT NULL`，否则会占用额外空间，优化器选择索引更复杂。

数据库 `IO` 操作的最小单位是页。数据页的主要作用是存记录，记录按主键组成单向链表，便于插入删除，用二分法查找。数据页有一个页目录，起到索引作用。一个页的记录划分为几个组，每个组最后一条记录存储组内的记录条数，页目录存储每个组最后一条记录的偏移量。由于按主键排序，可以快速定位记录在页目录的哪个槽，由槽定位到组和记录。

索引是为了加速查找，所以要有序，这样便于用二分查找。用数组保存，插入删除是个问题。用二叉搜索树，不易控制高度，磁盘 `IO` 增多。平衡二叉树保证左子树和右子树高度差不超过1，也不易控制高度，且不易维护。`B` 树能控制高度，但每个节点都存数据，非目标的数据也会加载一次，数据产生的磁盘 `IO` 甚至远远超过索引。所以用 `B+` 树，磁盘 `IO` 少，只有叶子节点存数据，存在冗余的节点，删除操作树的结构不会变化太大，叶子节点间用双向链表连接，对范围查询很友好。

为提高性能，`MYSQL` 会将表的索引装载进内存，当达到2000万量级，内存无法存储其索引，之后的查询会产生磁盘 `IO`，性能明显下降。

`InnoDB` 的 `B+` 树索引叶子节点存数据本身，`MyISAM` 的 `B+` 树索引叶子节点存数据的物理地址。

索引失效：范围查询。模糊匹配。对索引字段使用函数，因索引保存的是字段原始值，使用函数会失效，新版本可用函数计算的值建立函数索引。对索引进行表达式计算会失效。隐式类型转换，索引字段是字符串，条件查询用整数会失效；索引是整数，条件查询用字符串不会失效，因为遇到字符串和数字比较会自动将字符串转为数字。`OR` 前的列是索引列，`OR` 后的列不是索引列，索引会失效，因 `OR` 的含义是两个满足一个即可，只有一个条件列是索引列没有意义。

`count(column)` ：统计符合查询条件的记录中不为 `NULL` 的个数。`count(1)`：1永远不是 `NULL`，统计表记录数，若无二级索引遍历主键索引，不会读取值。`count(id)`：按主键查，如果有二级索引，优化器会选择用二级索引。`count(*)`：转换为 `count(0)` 处理。性能比较：`count(*)=count(1)>count(id)>count(column)`。

`MyISAM` 执行 `count(*)` 比 `InnoDB` 更快，每张表都有元数据信息存储行数，由表锁保证一致性。

# 事务

事务的特性：原子性，一个事务的所有操作，要么全部成功，要么全部失败。一致性：事务执行前后，数据库保持一致性状态。隔离性：多个事务并发执行，每个事务有独立的数据空间，防止数据不一致。持久性：事务完成后，对数据的修改是永久的。

持久性 `redo-log` 保证；原子性 `undo-log` 保证；隔离性 `MVCC` 和锁保证；一致性由原子性+隔离性+持久性保证。

处理多个事务可能出现的问题：脏读，一个事务读到另一个事务未提交事务修改过的数据。不可重复读，一个事务内多次读取同一数据，出现读取的数据不一致，未完成的事务读取了提交后的事务修改。幻读，一个事务多次读取到的数据行数不一致，未完成的事务读取了已提交事务新增的行。

事务隔离级别：读未提交，一个事务还没提交，做的变更就被其他事务看到。读提交，一个事务提交后，做的变更才能被其他事务看到。可重复读，一个事务执行中看到的数据，和事务启动时看到的数据一致。串行化，对记录加读写锁，发生锁冲突，后发生的事务等待先发生的事务完成。

`MVCC` 里的快照重要字段：`m_ids`，创建快照时当前活跃的事务列表。`min_trx_id`，创建快照时最小的活跃事务id。`max_trx_id`，创建快照时应该给下一个事务的id。`creator_trx_id`：创建该快照的事务id。

聚簇索引记录的两个隐藏列：`trx_id`，记录对某条记录改动的事务id。`roll_pointer`，每次改动记录，旧版本记录写入 `undo-log`，指向旧版本记录。

若记录 `trx_id` 小于快照的 `min_trx_id`，表示该记录在事务前已提交，对事务可见。若记录 `trx_id` 大于等于快照的 `max_trx_id`，该记录版本是创建快照后启动的事务生成，对当前事务不可见。若记录 `trx_id` 在快照 `min_trx_id` 和 `max_trx_id` 之间，`m_ids` 有该记录的 `trx_id`，表示生成该记录版本的事务仍活跃，对当前事务不可见，若不在 `m_ids`，表示已提交，可见。

`InnoDB` 默认隔离级别是可重复读，很大程度上避免了幻读。查询操作会始终用同一个数据快照，不会读取到幻影行。更新操作需要读取最新的数据，需要在间隔内加入间隙锁，阻止其他事务在该范围内插入。要避免特殊场景出现幻读，尽量开启事务后，执行当前读语句加上间隙锁，避免其他事务插入新记录。 

读提交和可重复读通过创建快照实现，读提交事务可能创建多个快照，可重复读启动事务时生成快照，事务期间只用这一个。

# 锁

全局锁：每次只能有一个线程更新数据库，用于全库逻辑备份，保证备份前后数据一致，会使数据库处于只读状态，如果支持可重复读，可开启事务备份，避免影响其他事务。

表级锁：表锁，分共享锁和独占锁，共享锁用于读，独占锁用于写。元数据锁，`CRUD` 表加 `MDL` 读锁，做结构变更加 `MDL` 写锁，如果有写锁被阻塞，后续的查询请求都会被阻塞。意向锁，加共享锁前会先给表加意向共享锁，加独占锁前会先给表加意向独占锁，对记录加锁前，先加对应的意向锁，这样其他线程加表级锁不用再遍历有没有记录持有行级锁，用于快速判断表里记录是否有加锁。

主键通常设为递增，插入数据会自动给主键赋递增的值。加一个表级别的 `auto-inc` 锁，插入执行完立即释放，但其他事务插入会被阻塞，影响性能。改进用轻量级锁，给字段赋递增值后就把锁释放，但是若 `bin-log` 格式是 `statement`，会导致数据的主键不一致，需要将格式设为 `row`，严格同步主库分配的值。

行级锁：只有 `InnoDB` 支持。普通的 `slect` 属于快照读不会对记录加锁，共享锁读读共享、读写互斥；独占锁写写互斥、读写互斥。记录锁，只对一条记录加锁，多个事务可同时会记录加共享锁，但有共享锁后不能加独占锁，当有事务加了独占锁，不能有其他事务加锁。间隙锁，解决可重复读隔离级别下幻读的现象，对某个间隔加锁，其他事务不能向该间隔插数据，间隙锁之间兼容，多个事务可持有共同间隔的间隙锁。临键锁，是记录锁+间隙锁，锁定记录及范围，既保护记录，又阻止插入幻影行。插入意向锁，事务插入记录时要判断是否有间隙锁，若有会阻塞，生成插入意向锁，表示等待，是特殊的间隙锁。

普通的 `select` 是快照读，用 `MVCC` 实现不会加锁。`update` 和 `delete` 会加行级独占锁。加锁的对象是索引，加锁的基本单位是临键锁，若能用记录锁或间隙锁避免幻读，临键锁会退化成记录锁或间隙锁。等值查询对单个记录加锁，再根据查找结果退化。范围查询对满足条件的索引加记录锁，防止多次被删除后少记录，对存在的值加间隙锁，防止查询出现新的结果集。

二级索引等值查询，直到扫描到第一个不符合条件的记录，符合条件的加临键锁，第一个不符合的退化成间隙锁。

插入语句插入一条记录前，先定位到在 `B+` 树的位置，若插入位置下条记录索引上有间隙锁，才会发生阻塞。

唯一索引范围查询满足一些条件锁会退化，非唯一索引范围查询不会退化。若是全表扫描，会对每个索引项加临键锁，相当于锁表。

非唯一索引还会对扫描到的记录对应的唯一索引加锁。

解决死锁：设置事务等待超时时间，开启主动死锁检测。

插入意向锁也属于间隙锁，但两个事务不能在同一时间，一个拥有间隙锁，另一个拥有该间隙的插入意向锁。

# 日志

三种日志：`undo-log` 回滚日志，存储引擎层生成，实现事务原子性，用于事务回滚和 `MVCC`。`redo-log` 重做日志，存储引擎层生成，实现持久性，用于故障恢复。`bin-log` 归档日志，`Server` 层生成，用于数据备份和主从复制。

执行增删改会隐方开启事务，执行完自动提交。事务提交前，记录更新前的数据到 `undo-log`，回滚时读取做相反操作。`delete` 不会立即删除，先打删除标记，最终操作交给 `purge` 线程。`update` 的列若是主键，直接反向更新，不是主键列，先删除该行再插入新行。记录每次更新产生的 `undo-log` 都有一个 `trx_id` 和 `roll_pointer`，记录修改的事务，`roll_pointer` 将每次修改串成版本链，还可以实现 `MVCC` 的快照读，如果读取的记录不满足，沿着 `undo-log` 版本链找到满足可见性的记录。`undo` 页和数据页的刷盘策略一致。

为防止断电导致脏页没及时更新，更新一条记录时，先更新内存，再将修改记录到 `redo-log`，此时更新就算完成。`WAL`：写操作不立即写到磁盘，先写日志，在合适的时间再写到磁盘。每执行一个事务会产生多条 `redo-log`，只要 `redo-log` 持久化到磁盘就可提交事务，系统崩溃重启可根据 `redo-log` 恢复。

更新记录前，先记录 `undo-log`，修改 `undo` 页后记录对应的 `redo-log`，`undo-log` 页需要持久性保护。

`redo-log` 记录的是事务修改后的状态，记录在数据页做的修改，记录更新后的值，用于崩溃恢复实现事务持久性。`undo-log` 记录的是事务修改前的数据，记录更新前的值，用于事务回滚保证事务原子性。

`redo-log` 以追加方式添加日志，是顺序写，数据页需要找到位置，是随机写，`redo-log` 写入开销小。`WAL` 将写操作从随机写变为顺序写，提升了执行性能。`redo-log` 先写到 `redo-log` 缓存，提交事务时或缓存使用超过一半时会触发落盘。

`redo-log` 有两个文件，写满一个切换到另一个，相当于环形。`re-log` 主要防止脏页丢失，脏页刷新到磁盘后擦除 `redo-log`。文件都写满了，会阻塞执行新操作，刷新脏页到磁盘清楚 `redo-log`。

执行更新操作后，`Server` 层生成一条 `bin-log`，事务提交后写入文件。`bin-log` 记录所有修改日志，用于所有存储引擎。三种格式类型：`STATEMENT`，修改 `SQL` 记录到 `bin-log`，主从复制根据 `SQL` 重现，但如果有动态函数，会出现数据不一致。`ROW`，记录行数据最终修改的状态，每行数据变化都记录会使文件过大。`MIXED`，混合使用两种模式。`bin-log` 是追加写，写满会创建新文件，保存全量日志，用于备份恢复、主从复制。

主从复制，将数据库所有变化以二进制形式保存在磁盘上，主库写 `bin-log`，提交事务，更新本地存储。从库创建 `IO` 线程接收主库生成的 `bin-log`，写入 `relay-log` 返回给主库复制成功。创建回放 `bin-log` 的线程，读 `relay-log` 实现主从数据一致性。

可以写数据只写主库，读数据只读从库。主库要创建 `log` 线程处理从库的复制请求，从库太多对主库资源消耗太大。事务执行过程，先把日志写到 `bin-log` 缓存，提交时再写到文件。一个事务的 `bin-log` 不能拆开，要保证一次写入。

更新的执行过程：执行期调用存储引擎接口，通过索引查找记录，若记录在缓冲池，直接读取。开启事务，先记录 `undo-log`，写入缓冲池的 `undo` 页，存储引擎更新记录，先更新内存标记为脏页，记录写到 `redo-log`，更新完成。记录该语句的 `bin-log`，提交事务。

事务提交后，`redo-log` 和 `bin-log` 要持久化到磁盘。如果出现半成功会出现主从数据不一致。`redo-log` 影响主库，`bin-log` 影响从库，二者需要一致。为避免两份日志逻辑不一致，用二阶段提交解决，实质是分布式事务的一致性协议。

二阶段提交把单个事务提交拆成两个阶段，准备和提交。`bin-log` 作为协调者，存储引擎是参与者。准备阶段：`redo-log` 中写入事务ID，事务状态设置为准备，`redo-log` 持久化。提交阶段：事务ID写入 `bin-log`，持久化到磁盘，将 `redo-log` 事务状态设置为提交。

崩溃恢复后如果碰到准备状态的 `redo-log`，去 `bin-log` 查是否该有事务，若没有则回滚事务，若有则提交事务。`bin-log` 写成功是二阶段提交事务提交成功的标识。

二阶段提交会影响性能，每个事务提交要刷两次盘，磁盘 `IO` 高。在多事务情况下，为保证提交顺序一致，需要加锁。`bin-log` 组提交，多个事务提交，会将多个 `bin-log` 刷盘操作合并成一个，减少 `IO` 次数。

若磁盘 `IO` 高，延迟 `bin-log` 和 `redo-log` 持久化。

# 内存

为提高读写性能，`InnoDB` 设计了缓冲池，读取数据先读缓冲池，读不到再读磁盘。修改数据，若在缓冲池，修改后标记为脏页，等待后台线程将脏页写入磁盘。

缓冲池分配到内存后，划分成页。缓冲池存索引页、数据页、`undo` 页、插入缓存、自适应哈希索引、锁信息。查询一条记录，会将整页数据加载到缓冲池，通过页目录定位记录。

缓冲池用控制块指向一个缓存页，用空闲链表维护空闲的缓存页。`Flush` 链表维护脏页，后台线程只需要遍历 `Flush` 链表即可把脏页写入磁盘。

提高缓冲命中率用 `LRU` 算法。`InnoDB` 提供缓冲池，数据存在缓冲池直接读取，否则从磁盘读取。修改数据先改缓冲池，标记为脏页，后台线程将脏页写入磁盘。改进预读失效：在 `LRU` 链表上划出两个区域，`young` 和 `old`，每个区域有各自的头尾节点，区域占比约63:37。预读页加入到 `old`，真正被访问时才插入到 `young`。若预读页一直未被访问，会从 `old` 移除，不会影响到 `young` 中的热点数据。

触发脏页刷新：`redo-log` 满了。缓冲池空间不足淘汰的是脏页。如果偶尔有一些慢 `SQL`，可能是脏页刷新带来的性能开销导致抖动。

# 补充

`SQL` 数据库指关系型数据库，数据逻辑上以行列二维表形式存在，支持 `ACID`。`NoSQL` 非关系型数据库，支持 `BASE`，数据间无关系，非常容易扩展。

数据库三大范式：`1NF`，每个列是不可分割的。`2NF`，每个列都和主键相关。`3NF`，每个列和主键直接相关，不能间接相关。

`CHAR` 是固定长度的字符串类型，定义时需指定长度，存储在末尾补足空格，对短字符串效率高。`VARCHAR` 是可变长字符串类型，定义时需指定最大长度，根据实际长度占用空间，存储长度可变的数据能节省存储。

外键约束：维护表和表间的关系，确保数据的完整性和一致性。一张表的主键作为另一张表的外键，确保出现不存在的数据。如学生表和课程表，确保学生选的课存在，课程表主键作为学生表外键。

`IN` 检查左边表达式是否在右边的结果集，`EXISTS` 判断子查询是否返回结果，不关心返回什么数据。很多情况下 `EXISTS` 性能优于 `IN`，子查询表很大时，`EXISTS` 找到匹配项立即停止，`IN` 可能扫描整个子查询结果集。

```sql
SELECT * FROM Customers
WHERE EXISTS (SELECT 1 FROM Orders WHERE Orders.CustomerID = Customers.CustomerID)
```

适合做主键的字段：具有唯一性不能为空，有递增趋势否则插入会导致页分裂，最好不用自增字段做主键，避免分布式环境同步不一致。

为避免主从延迟，强制走主库。

分库：水平扩展数据库，将数据根据一定规则分到多个独立数据库，主要解决并发连接多。分表：单个数据库的表分成多个表。垂直拆分：分库，按业务类型对数据分离。分表：把业务宽表独立的字段拆开，大表拆小表。水平拆分：分库，同一个表按一定规则拆到不同的数据库，数据访问需要路由工作。分表，把一张大数据量的表按一定规则拆成多个结构完全相同的表。

