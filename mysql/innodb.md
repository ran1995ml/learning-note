# 连接器

`MySQL` 基于 `TCP` 传输，连接分为长短连接。长连接可减少建立连接和断开连接的次数，但长连接过多会导致连接占用过大。解决方法：定期断开长连接释放内存；客户端主动重置连接，不需要重做校验。

# 查询缓存

服务器端收到查询请求，先在查询缓存查找，以 `key-value` 保存，`key` 为 `SQL` 语句，`value` 为结果。但对更新频繁的表，查询缓存的命中率很低，查询缓存会在有更新操作后清空。

# SQL执行

解析器解析 `SQL` 语句，先做词法分析，从 `SQL` 识别出关键字；再做语法解析，根据语法规则构建语法树后准备执行。预处理阶段检查表和字段是否存在；优化器确定执行计划，决定要使用的索引；执行器和存储引擎交互开始执行。

# 表文件

一个数据库对应一个目录。对于一张表，`.frm` 文件保存表的元数据信息，`.ibd` 文件又叫独占表空间文件，保存表数据。

表空间由段、区、页、行组成。

表记录按行存放，数据按页来读取，每个页默认16 `KB`，读一条记录会将整页读入内存，页是存储引擎磁盘管理的最小单元，分为数据页、`undo` 日志页、溢出页等。

`InnoDB` 用 `B+` 树组织数据，树中每层通过双向链表连接。若链表中相邻的两个页物理位置不是连续的，查询时会有大量随机 `IO`。为保证相邻页顺序读写，表数据量大的时候，为索引分配空间按区分配，每个区1 `MB`，64个页被划为一个区。

段组成表空间，由多个区组成，分为数据段、索引段和回滚段：

- 索引段：存放 `B+` 树非叶子节点的区集合；
- 数据段：存放 `B+` 树叶子节点的区集合；
- 回滚段：存放回滚数据的区集合，`MVCC` 用回滚段实现多版本查询。

`InnoDB` 一条记录存储格式默认使用 `Compact` 作为行格式。

![Compact](./diagram/Compact.png)

`char` 是定长的，`varchar` 是变长的，变长字段长度列表存储数据的长度，按列的顺序逆序存放，因记录头信息指向下一条记录的记录头，逆序存放方便读取。

`NULL` 值列表，每个列对应一个位，按列逆序排列。若列都定义成 `NOT NULL`，行格式不会有 `NULL` 值列表，可节省空间。

记录头信息：`delete_mask`，标识记录是否被删除；`next_record`，下一条记录的位置；`record_type`，记录类型，0为普通记录，1表示 `B+` 树非叶子节点记录，2为最小记录，3为最大记录。

若建表没有指定主键或唯一约束列，就没有 `row_id` 字段。`trx_id`，表示生成数据的事务。`roll_ptr`，该记录上个版本的指针。

若一个页存不了一条记录，溢出的数据会存放到溢出页，真实数据会用20字节存储指向溢出页的地址。

# 索引

若有主键，`InnoDB` 用主键作为聚簇索引的索引键；若无主键，第一个不包含 `NULL` 的唯一列作为聚簇索引的索引键；否则，自动生成自增列作为聚簇索引的索引键。其他索引都是辅助索引，又叫二级索引或非聚簇索引。

索引默认用 `B+` 树，叶子节点存放数据，非叶子节点只存放索引，每个节点的数据按主键顺序存放，每层父节点的索引值都会出现在下层子节点的索引值中，叶子节点包括了所有索引值信息，每个叶子节点有两个指针，指向下一个叶子节点和上一个叶子节点。

![B+Tree](./diagram/B+Tree.png)

`B+` 树从根节点向下查找，每读取一个节点做次磁盘 `IO`。`B+` 树存储千万级数据只需3-4层，相比于 `B` 数查询效率高，磁盘 `IO` 少。

主键索引的 `B+` 树叶子节点存放的是数据，二级索引的 `B+` 树叶子节点存放的是主键值，需要回表才能查到数据。

覆盖索引，查询的列包含在索引中，只查二级索引就可取得结果的过程。

`B+` 树只在叶子节点存数据，`B` 树的非叶子节点也要存数据，`B+` 树在相同 `IO` 次数下，可查更多的节点。哈希表不适合做范围查询，只适合做等值查询。

一张表只能有一个主键索引，索引列的值不能为 `NULL`。唯一索引建立在 `UNIQUE` 字段，一张表可有多个，允许有空值。普通索引，建立在普通字段上，对列没要求。前缀索引，对字符类型字段的前几个字段建立的索引，而不是在整个字段上建立，作用是减少索引占用的存储空间，提升查询效率。

单列索引，建立在单列上；联合索引，建立在多列上，先按第一列排序，第一列值相等时再按下一列排序。使用联合索引时存在最左匹配原则，按最左优先的方式匹配索引，否则索引会失效，因为有查询优化器，字段的顺序不重要。使用索引的前提要保证索引里的 `key` 是有序的，联合索引不遵循最左匹配原则，会导致索引变得无序，无法使用。最左匹配原则向右匹配遇到范围查询会停止，但在 `>=` 条件或 `like` 条件下不会停止。

对范围查询，按第一个列的索引找到记录后，需要回表找出数据行，再对比第二个列值。索引下推优化，可在联合索引遍历过程中，对包含的字段先判断，直接过滤掉不满足条件的记录，减少回表次数。

联合索引的字段顺序对效率影响很大，要把区分度大的字段放在前面，也就是字段的值较多。如果某个值在数据中的百分比很高时，会忽略索引做全表扫描。

`order by` 会产生文件排序，为避免排序，可在要 `order by ` 的字段上建立联合索引。

索引的好处是可提高查询速度，缺点是需要占用物理空间，创建维护索引要耗费时间，会降低表的增删改效率。

适用索引的场景：字段有唯一性限制；经常用于 `WHERE` 子句；经常用于 `GROUP BY` 和 `ORDER BY`，查询时不需要再做一次排序。

不需要索引：字段有大量重复值；表数据太少；经常更新的字段。

索引优化：前缀索引是为了减少索引字段大小，适用于大字符串，但是 `order by` 无法使用，不能用作覆盖索引；覆盖索引可避免回表，建立联合索引包含所有需要查询的字段，可避免回表；主键索引要设置为递增，使用自增主键，每次插入新数据可顺序加到当前索引节点位置，不需要移动已有数据，页面写满，可开辟新页面，若用非自增主键，每次插入的值是随机的，可能需要移动数据，会产生页分裂，造成大量内存碎片，影响查询效率；主键长度不能太大，这样可节省二级索引叶子节点空间；索引列最好设置为 `NOT NULL`，避免优化器选择索引时更难优化，节省存储。

索引失效的情况：用左或左右模糊匹配；查询条件中对索引列做了计算、函数、类型转换；联合索引没有遵循最左匹配原则；

# 存储引擎

存储引擎是基于表的，而不是数据库。

`InnoDB` 支持事务，行锁设计、支持外键。通过 `MVCC` 获得高并发性，默认是 `REPEATABLE` 级别，用 `next-key locking` 避免幻读。提供了插入缓冲、二次写、自适应哈希索引、预读等功能。每张表的存储按主键顺序存放，没有显式指定主键，会为每行生成一个 `ROWID`。

`MyISAM` 不支持事务、表锁设计、支持全文索引。缓冲池只缓冲索引文件，不缓冲数据文件。

`Memory` 将表中的数据存放在内存中，重启后数据会消失。适用于存储临时数据的临时表，使用哈希索引。不支持 `TEXT` 和 `BLOB`，只支持表锁。

## InnoDB

`InnoDB` 存储引擎包括缓冲池、后台线程和数据文件。

后台线程：

- `Master` 线程：异步刷新缓冲池数据到磁盘，包括脏页刷新、合并插入缓冲、`undo` 页回收。
- `IO` 线程：处理 `IO` 请求，有 `write`、`read`、`insert buffer` 和 `log`。
- `Purge` 线程：事务提交后，回收已分配的 `undo` 页。
- `Page Cleaner` 线程：刷新脏页。

`InnoDB` 基于磁盘存储，记录按页管理。因为 `CPU` 和磁盘速度有差距，通常用缓冲池提高性能。缓冲池是一块内存，将从磁盘读到的页放入缓冲池，下次再读相同的页，判断该页是否在缓冲池中，否则读取磁盘上的页。页的修改，先修改在缓冲池的页，以 `checkpoint` 机制刷新回磁盘。

缓冲池缓存的数据页类型有：索引页、数据页、`undo` 页、插入缓冲、自适应哈希索引和锁信息。可以配多个缓冲池，每个页按哈希值平均分配。缓冲池通过 `LRU` 算法管理，最频繁使用的页放前端，最少使用的页放尾段。改进后的 `LRU` 不会将最新读取的页放在首部，避免某个特殊查询加载过多的页导致热点页被移除。

脏页，缓冲池中的页和磁盘上的页数据不一致，加入 `Flush` 列表等待刷新磁盘，同时保留在 `LRU` 列表保留可用性。刷新脏页时如果宕机，数据不能恢复，所以事务提交时，先写 `redo` 日志，再修改页，恢复可通过 `redo` 日志完成，实现了事务持久性的要求。

`checkpoint` 机制缩短数据库的恢复时间，缓冲池不够用或 `redo` 日志不可用时，刷新脏页。

`Master` 线程有最高的优先级，主循环的操作：刷新日志缓冲到磁盘，即使事务还没提交，提高事务提高效率；合并插入缓冲，判断上一次执行的 `IO` 次数，`IO` 压力很小时执行合并插入缓冲操作。

插入缓冲是物理页的一个组成部分，对非聚集索引的插入或更新，不是每次直接插入到索引页，而是先判断插入的非聚集索引页是否在缓冲池中，若在直接插入，否则先放到插入缓冲，等待合并，提高对非聚集索引插入的性能。插入缓冲的使用条件：辅助索引；索引不是唯一的。

插入缓冲的数据结构是一棵 `B+` 树，用于存放所有表的辅助索引，非叶节点放查询的键值。当一个辅助索引要插入到页，若页不在缓冲池，先将键值插入到

# 文件

表和数据库的文件构成：

- 参数文件：`my.cnf`，启动时读取数据库文件的位置、初始化参数。
- 日志文件：包括错误日志、慢查询日志、`bin-log` 等。
  - 慢查询日志可借助 `mysqldumpslow` 分析，高版本可查询 `mysql.slow_log` 表。
  - 查询日志记录了对数据库请求的信息。
  - `bin-log` 记录了对数据库的修改操作，用于某时间点数据还原和复制。未提交的 `bin-log` 先写入缓存，事务提交后刷新到日志文件。`sync_binlog=1` 可确保同步写磁盘，但如果事务未提交，记录到 `bin-log` 不能回滚，设置 `innodb_support_xa=1` 确保数据文件和 `bin-log` 的同步。`binlog_format` 有 `STATEMENT` 和 `ROW` 两种，`STATEMENT` 记录逻辑 `SQL` 语句，`ROW` 记录表的行更改情况，恢复更快，但日志文件更大。查看 `bin-log` 借助工具 `mysqlbinlog`。
- 表结构文件：按表存储数据，每个表都有对应的文件。`frm` 文件记录表结构定义，存放视图。
- `socket` 文件：用 `socket` 连接时需要的文件。
- `pid` 文件：进程 `ID` 文件。
- 存储引擎文件：包括表空间文件、 `redo-log` 、`undo-log`。
  - 表空间存放数据、索引。
  - `redo-log` 保证每个事务操作写入磁盘，若宕机重启后用 `redo-log` 恢复，实现事务持久性。记录每个页的更改情况，事务进行过程不断写入，先写入缓冲，刷到磁盘按一个扇区大小，写入必定成功，不需要双写。`Master` 线程每秒会刷一次 `redo-log`。
  - `undo-log`，回滚日志，记录事务发生前的版本，发生错误时回滚，实现事务原子性。



