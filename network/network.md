# 网络模型

应用层不关注数据如何传输，工作在用户态，传输层及以下工作在内核态。应用层数据传给传输层，传输层为应用层提供网络支持。

`TCP` 比 `UDP` 多了很多特效，如流量控制、超时重传、拥塞控制等来保证数据可靠传输，`UDP` 只负责发送数据包，不保证数据包抵达对方，实时性更好，传输效率更高。如果数据包过大，会分块，这样分段丢失或损坏只需要发送这一个，每个分块称为段。传输层报文有端口号，接收方可识别出是发送给哪个应用。

传输层服务好应用，实际的传输功能由网络层实现。`IP` 协议将传输层报文作为数据部分，加上 `IP` 包头组成 `IP` 报文。网络层负责将数据从一个设备传输到另一个设备。`IP` 地址分为：网络号标识属于哪个子网，主机号标识同一子网下的不同主机，可用子网掩码算出。寻址先匹配到相同的网络号再找到对应主机。

生成 `IP` 头部交给数据链路层，加上 `MAC` 头部封装成数据帧发送到网络。`MAC` 地址标识网络上的设备，数据链路层工作在网卡层次，为网络层提供链路级别传输服务。

# 浏览器工作

浏览器先解析 `URL`，确定 `Web` 服务器和文件名生成 `HTTP` 请求消息，委托操作系统发送给 `Web` 服务器。

`DNS` 服务器保存域名和 `IP` 的对应关系。客户端先发出 `DNS` 请求到本地 `DNS` 服务器，先查询缓存，若缓存没有发送到根 `DNS`，指明要查询的顶级 `DNS`、权威 `DNS`，最后返回 `IP` 地址到本地 `DNS`。

浏览器先查自身缓存，再查操作系统缓存，再查 `hosts` 文件，最后才会去问本地 `DNS`。

获取到 `IP` 后，`HTTP` 的传输工作交给操作系统的协议栈，浏览器调用 `Socket` 库委托协议栈。

`TCP` 包组成：源端口号和目标端口号；包序号，解决包乱序；确认号，确认包发出去对方能收到，没收到重新发送，解决丢包问题；状态位，`SYN` 发起连接，`ACK` 是回复，`RST` 是重新连接，`FIN` 是结束连接，`TCP` 是面向连接的，双方要维护连接的状态；窗口大小，用于流量控制，标识自己当前的处理能力，拥塞控制，控制发送速度；数据部分，存放 `HTTP` 头和数据。

`TCP` 连接建立，为三次握手，实质是双方维护一个状态机，保证双方都有发送和接收能力。

添加 `IP` 头和 `MAC` 头后，通过网卡转换为电信号，从网线发送出去。通过交换机找到目标 `MAC` 地址，再通过路由器找到目标 `IP` 地址。

# Linux网络

`OSI` 网络模型：应用层，提供统一接口给应用程序；表示层，把数据转换成兼容另一系统能识别的格式；会话层，建立管理实体间的通信会话；传输层，端到端的数据传输；网络层，数据转发、路由、分片；数据链路层， `MAC` 寻址；物理层，物理传输数据帧。

应用程序通过系统调用，和 `Socket` 层进行数据交互，`Socket` 层下面就是传输层、网络层和网络接口层，最下面一层是网卡驱动程序和硬件网卡设备。

网卡收到网络包，通过 `DMA` 写入网络缓冲区，通知操作系统。发送数据，调用 `Socket` 数据进入 `Socket` 缓冲区，通过网卡发送。

# HTTP

超文本传输协议，协议需要有多个参与者，是对参与者的约束，确立计算机通信的规范。超文本是文字、图片、视频的混合体，有超链接，能从一个超文本跳转到另一个超文本。`HTML` 是最常见的超文本，本身是纯文字文件，用标签定义了图片、视频链接，经浏览器解释呈现出网页。

`HTTP` 是计算机间传输文字、图片、视频等数据的约定和规范。

状态码：`1xx`，提示信息；`2xx`，服务器成功处理了客户端请求；`3xx`：客户端请求资源变动，需要用新的 `URL` 重新获取；`4xx`，客户端发送报文错误，服务器无法处理；`5xx`，服务器处理时发生错误。

常见字段：`Host` ，指定服务器域名；`Content-Length`，本次回应数据长度；`Connection`，指定用长连接；`Content-Type`，服务器回应客户端本次数据是什么格式；`Content-Encoding`，说明返回数据的压缩格式。

`GET`：从服务器获取指定资源，参数位置在 `URL`。`POST`：根据请求体处理指定资源。安全，请求方法不会破坏服务器资源；幂等，多次执行相同操作结果是相同的。`GET` 方法是安全幂等的，可缓存到浏览器；`POST` 不是安全幂等的，一般不会缓存到浏览器。`HTTP` 传输内容都是铭文，抓包就能看到，避免数据在传输中泄漏要用 `HTTPS`。

`HTTP` 缓存：强制缓存，浏览器缓存未过期则使用，在请求头控制。协商缓存，与服务器协商后决定是否用本地缓存。

`HTTP1.0`：优点，简单，报文格式 `header+body`，头部信息 `key-value`，跨平台易扩展；缺点，无状态，服务器不记录 `HTTP` 状态，减轻了服务器负担，但在完成关联性操作会很麻烦，每次操作都要验证信息，明文传输不安全。

`HTTP1.0` 通过长连接减少 `TCP` 连接的重复建立和断开连接的开销，减轻服务器负载，当超过一段时间没有数据交互，服务端主动断开连接。管道机制允许一个 `TCP` 连接客户端可发起多个请求，减少整体的响应时间，服务端必须按照接收请求顺序响应管道请求，但是第一个请求阻塞会导致后续所有请求被阻塞，默认不开启。

`HTTPS` 解决 `HTTP` 安全问题，在 `TCP` 和 `HTTP` 网络层间加入 `SSL/TLS` 安全协议，使报文加密传输，在 `TCP` 三次握手后进行 `SSL/TLS` 握手，需要向 `CA` 申请数字证书保证服务器身份可信。

`HTTP2` 的优化：压缩 `Header` 消除重复部分；`Header` 和 `Body` 改为二进制格式，增加数据传输效率；并发传输；服务器主动推送。

优化 `HTTP`：尽量避免发送 `HTTP` 请求，对重复性请求使用缓存；合并请求；减少响应数据大小，压缩。

长轮询，将超时时间设置大些，减少 `HTTP` 请求个数，发起一个请求，在较长时间等待服务器响应。

# RPC

`TCP` 面向连接、可靠、基于字节流。因为基于字节流，没有任何边界，这就是粘包问题，需要加一些自定义的规则区分消息边界。加入消息头包装要发送的数据，根据长度截取真正要传输的消息体，于是衍生出其他协议如 `HTTP` 和 `RPC`。

`RPC`，远程过程调用，本身不是一种具体协议，而是一种调用方式，屏蔽掉网络细节调用远端服务器的方法，如 `gRPC` 和 `thrift`。底层不一定要用 `TCP`，`UDP` 或 `HTTP` 也行。

`HTTP` 是针对浏览器，需要访问多个服务器，用 `RPC` 可以只针对自己的服务器。`HTTP` 需要知道服务域名，`RPC` 可以有专门的中间服务保存服务名，通过中间服务去发现服务。`RPC` 建立 `TCP` 长连接进行数据交互，还会建个连接池便于复用。

基于 `TCP` 传输的消息包括消息头和消息体，消息头放一些特殊信息如消息体长度，消息体放真正传输的内容。`HTTP` 用 `json` 序列化数据，消息头比较大。`RPC` 定制化比较高，可用体积更小的 `Protobuf` 保存数据，不需要考虑浏览器的行为，如 `3xx` 重定向，性能会更好。

# WebSocket

`TCP` 是全双工的，双方都可主动向对方发送数据。`HTTP1.1` 是半双工的，同一时间客户端和服务器只能有一方主动发数据。

`WebSocket` 基于 `HTTP`，在 `HTTP` 请求加上特殊的头，带上随机生成的 `base64` 码，服务端对其解码，如果支持，经过两次握手建立了连接。只有建立连接时用到了 `HTTP`。

全双工通信，适用于客户端和服务器需要频繁交互的场景，如聊天室、小游戏。

# TCP

头格式：序列号，建立连接时生成随机数作为初始值，通过 `SYN` 包传输，每发送一次数据累加一次，避免网络包乱序。确认应答号，下次期望接收的序列号，发送段可认为该序列号之前的数据都被正常接收，解决丢包问题。

`IP` 层是不可靠的，不保证网络包按序交付、数据完整，因此数据的可靠性需要 `TCP` 负责，确保接收的网络包无损坏、无间隔、按序。

`TCP` 特点：面向连接，一定是一对一；可靠，保证报文一定到达接收端；字节流，有序，但没有消息边界。

`TCP` 的另一种定义：用于保证可靠性和流量控制维护的状态信息组合。`Socket`，由 `IP` 和端口号组成。序列号，解决乱序问题。窗口大小，做流量控制。

源地址、源端口、目标地址、目标端口可确定唯一的一个 `TCP` 连接。

`UDP` 不提供复杂的控制机制，利用 `IP` 提供面向无连接的服务。只包含源端口和目标端口、包长度、校验和。

`TCP` 面向连接，`UDP` 不需要连接；`TCP` 只支持一对一，`UDP` 支持一对多；`TCP` 保证数据无差错、不重复、按序到达，`UDP` 不保证可靠交付；`TCP` 拥有流量控制和拥塞控制机制，保证数据传输安全；`TCP` 头部开销较大；`TCP` 是流式传输无边界，`UDP` 是按包发送有边界不会切分；`TCP` 用于文件传输，`UDP` 用于视频音频通信。

`TCP` 和 `UDP` 在内核是完全独立的模块，可用同一个端口。

三次握手，服务端监听某端口，处于 `LISTEN`。客户端生成初始化序号，`SYN` 为1，把 `SYN` 报文发给服务端发起连接，该报文不包含应用层数据，客户端处于 `SYN-SENT`。服务端收到 `SYN` 报文，生成初始化序号，客户端的序列号加一填入确认应答号，`SYN` 和 `ACK` 为1，发给客户端，处于 `SYN-RCVD`。客户端收到报文，`ACK` 为1，确认应答号置为服务端序列号加1，发给服务端，处于 `ESTABLISHED`。服务端收到报文，也进入 `ESTABLISHED`。

前两次握手不可携带数据，第三次握手可携带数据。

三次握手可避免重复历史连接，同步双方初始化序列号，避免资源浪费。

序列号是可靠传输的关键因素，接收方可去除重复数据，按照序列号按序接收，确认哪些数据包被接收。

`IP` 层没有超时重传机制，如果某个网络包丢失，`TCP` 需要把整个数据包重传，因此 `TCP` 会对数据包做分片。

四次挥手，客户端打算关闭连接，`FIN` 置为1，发送 `FIN` 报文，进入 `FIN_WAIT_1`。服务端收到发送 `ACK` 报文，进入 `CLOSE_WAIT`。客户端收到 `ACK` 报文，进入 `FIN_WAIT_2`。服务端处理完数据，发送 `FIN` 报文给客户端，进入 `LAST_ACK`。客户端收到 `FIN` 报文，回复一个 `ACK` 报文，进入 `TIME_WAIT`。服务端收到 `ACK` 报文，进入 `CLOSE`，客户端等待一小段时间，也进入 `CLOSE`。

关闭连接，客户端发送 `FIN`，仅表示客户端不再发送数据但还能接收数据。服务端收到 `FIN`，回复 `ACK` 表示还有数据要发送，等不再发送数据时，才发送 `FIN` 表示同意关闭。

`ACK` 报文不会重传，超时只会再发送 `FIN` 或 `SYN`。

服务器出现大量 `TIME_WAIT`，说明服务器主动断开很多 `TCP` 连接。原因：`HTTP` 没有长连接，`HTTP` 长连接超时；`HTTP` 长连接请求数量达到上限。

服务器出现大量 `CLOSE_WAIT`，说明服务端程序没调用 `close` 关闭连接。

如果在一个时间段内，没有任何连接相关的活动，触发 `TCP` 保活机制，每隔一个时间间隔发送探测报文，若没有响应则认为 `TCP` 连接死亡。`TCP` 的超时时间较长，通常由应用层自定义超时机制。

`TCP` 的可靠传输通过序列号与确认应答实现。

超时重传，发送数据时设定一个定时器，超过指定时间后若没有收到 `ACK` 则重发数据。数据包丢失活确认应答丢失会触发。`RTT`，数据发送时到收到确认的时间差值。`RTO`，超时重传时间。`RTO` 应该略大于 `RTT`。

滑动窗口，解决往返时间较长的情况。无需等待确认应答，可继续发送窗口大小的数据个数。实质是操作系统开辟的缓存空间，收到应答前保留，按期收到应答后从缓冲区删除。`TCP` 头会加上窗口大小，告诉接收端接收能力，不会导致接收端处理不过来。

流量控制，`TCP` 提供一种机制让发送方根据接收方的实际接收能力控制发送的数据量，避免发送方数据填满接收方的缓存，根据接收方的窗口大小动态调整发送方窗口。

拥塞控制，避免发送方数据填满整个网络。发送方维护一个拥塞创建，根据网络拥塞程度动态变化。若发生超时重传，则认为网络出现拥塞。拥塞控制算法：慢启动，一点点提高发送数据包的数量，发送方每收到一个 `ACK`，增加拥塞窗口大小，呈指数增长。拥塞避免，拥塞窗口超过慢启动门槛使用，由指数增长变为线性增长。拥塞发生，发生超时重传时使用，调整慢启动门槛为原来的一半，窗口大小复位到1开始执行慢启动。快速恢复，直接回到慢启动会影响吞吐量，快速恢复将窗口大小设为之前的一半，再执行拥塞避免算法。

`TCP` 优化：三次握手平均占一个 `HTTP` 请求时间的10%，每次重传超时时间是上一次的两倍，根据网络稳定性和服务器繁忙程度修改重传次数，尽快暴露错误。服务端内核会建立半连接队列维护未完成的连接，检查是否存在半连接队列溢出。调整滑动窗口增加吞吐量。

`TCP` 是面向字节流的协议，`UDP` 是面向报文的协议。`UDP` 传输不会对消息拆分，拆分交给网络层，接收方读的 `UDP` 报文是完整的用户消息。`TCP` 面向字节流意味着不知道消息的边界，无法读取有效用户信息。

粘包问题：不知道用户消息的边界。解决方法：固定每个用户消息的长度，该方法简单但不灵活。特殊字符作为边界，`HTTP` 通过设置换行符作为边界，要注意特殊字符转义。自定义消息结构，指定字段长度，直到读满数据长度。

`TCP` 每次建立连接的初始化序列号都不一样，目的是为了防止历史报文被接收。

`SYN` 报文被丢弃的场景：超过重试次数；内核 `TCP` 队列溢出。