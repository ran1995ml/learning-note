数组：连续的内存空间，适合随机访问，插入删除效率低。链表：内存不连续，随机访问慢，适合频繁插入删除。栈：先进后出。队列：先进先出。树：非线形结构，表示层次关系。

队列适用于需要按照插入顺序处理的场景，如任务调度。栈适用于维护最近操作的状态，如函数调用。

平衡二叉搜索树，目的是缩短插入、删除、修改和查找节点的时间。将二叉搜索树平衡均匀地分布，减少二叉搜索树的深度。左右子树的高度差不超过1，左右子树都是一棵平衡二叉树。

红黑树是一种自平衡的二叉搜索树，插入删除后通过旋转和重新着色保持树平衡。

跳表基于链表，添加多层索引加速搜索。每个节点包含指向下一层和右侧节点的指针，实现比红黑树更简单，空间复杂度稍高。

`epoll` 用红黑树检查监听的 `socket`，`redis` 用跳表实现 `zset`。

`B+` 树是一种自平衡的多路查找树，所有叶子节点在同一层，非叶子节点只包含索引信息，数据只放在叶子节点。`B` 树所有节点都存数据和索引，可能在非叶子节点返回，占用存储较多。

堆是一棵完全二叉树，节点值都大于等于子节点为大顶堆，节点值都小于等于子节点为小顶堆，主要应用于取前 `n` 个最大/最小的元素，构建堆后，读取剩下的元素更新堆。

布隆过滤器，用于判断一个元素是否在一个集合中，只关心元素存在不存在。保存一个二进制向量，结合哈希实现，可告诉一个元素绝对不在集合中，但因为哈希碰撞对集合内存在的元素有一定误判率。首先创建一个全为0的位数组，选择几个独立的哈希函数，添加元素时，用所有哈希函数计算得到几个位置，将其标记为1。检查一个元素是否在集合中，计算得到标记为1的位置，若所有位置都被标记为1，可以说元素可能在集合中，若任何一个位置都不为1，则元素肯定不在集合中。可通过提高数组长度和哈希计算次数降低误报率。

排序稳定性，排序过程中相同关键字的元素排序后保持原有的相对顺序。规定排序是稳定排序，快速排序不是稳定排序，但当待排序关键字随机分布时，快速排序平均时间最短。

对一个很大的数据集排序，没办法一次性在内存排序，用外部排序解决。将待排序文件拆成多个部分，每个部分足以存入内存，将多个文件部分排序，可用快速排序，输出到临时文件，每个临时文件是有序的。对临时文件做归并排序，合并成一个文件。