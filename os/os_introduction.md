# 操作系统简介

程序运行做的事情：执行指令。处理器从内存取一条指令，解码后执行，完成后再继续执行下一条指令，直到程序完成。

操作系统实际做了什么：取得CPU、内存或磁盘等物理资源，对其进行虚拟化；处理并发；持久存储文件。

目标一：最小化操作系统的开销。目标二：应用程序间及OS和应用程序间提供保护，实现进程间彼此隔离。

# 虚拟化

为了让系统更易于使用，操作系统主要利用虚拟化技术。将物理资源转换为更通用、更强大且更易于使用的虚拟形式。

## 虚拟化CPU

虚拟化CPU，基本思想：运行一个进程一段时间，再运行另一个进程。通过时分共享CPU实现虚拟化。需要以高性能虚拟化CPU，同时保持对系统的控制。

### 受限直接执行

为高效执行，直接在CPU上运行程序，又需要对进程加一些限制，避免进程完全控制系统。用户模式下，运行的代码会受限，不能发出IO请求；内核模式下，运行的代码可以发出IO请求和执行受限指令。

执行系统调用，程序需执行 `trap` 指令，该指令会跳入内核将特权提升到内核模式，调用完成后，操作系统调用从 `trap` 返回指令，回到用户模式。执行 `trap` 时，要确保存储足够的调用者寄存器，能正确返回。

如果应用程序执行了非法操作，会将控制转移给操作系统。操作系统通过时钟中断重获CPU的控制器，避免程序恶意占用CPU。

上下文切换，为当前进程保存一些寄存器的值，为即将执行的进程恢复一些寄存器的值。

### 进程

进程是操作系统为正在运行的程序提供的抽象。进程的机器状态组成：

- 内存：指令存在内存中，正在运行的程序读取和写入的数据也在内存中；
- 寄存器：程序计数器、栈指针、帧指针。

运行程序需要将代码加载进内存中，现代操作系统惰性执行该过程，仅在程序执行期间需要加载代码片段时，才会加载。进程的状态：

- 运行：进程正在处理器上运行；
- 就绪：进程已准备好运行，但由于某种原因，操作系统不在此时运行；
- 阻塞：一个进程执行了某种操作，直到发生其他事件时才会运行。如进程向磁盘发起IO请求时会被阻塞。

常用的进程 `API`：

- `fork()`：会创建一个子进程，和父进程几乎一样。子进程不会从 `main()` 开始执行，而是从 `fork()` 返回。子进程返回值是0，父进程的返回值是子进程的 `PID`。
- `wait()`：延迟进程的执行，控制子进程执行完毕才返回父进程。
- `exec()`：从可执行程序中加载代码和静态数据，覆写代码段，初始化堆栈。没有创建新进程，而是将当前运行的程序替换成不同的程序。
- `pipe()`：一个进程的输出被链接到一个内核管道上，另一个进程的输入被链接到同一个管道上。
- `kill()`：向进程发送信号，包括要求进程睡眠、终止等。

进程调度指标：

- 周转时间：任务完成时间减去任务到达系统的时间。
- 响应时间：任务首次运行时间减去任务到达系统时间。

调度算法：

- `FIFO`：先来先服务。优点，简单易实现。如果有长任务，平均周转时间会降低。
- `SJF`：先运行最短任务，然后是次短任务。如果长任务先达到，平均周转时间会降低。
- `STCF`：最短完成时间有优先，向 `SJF` 添加抢占，每当有新工作进入系统，确定剩余工作和新工作中，谁的剩余时间最少，选择调度工作。平均周转时间减少，但响应时间和交互性差。
- `Round-Robin`：轮转，在一个时间片内运行一个工作，然后切换到运行队列的下一个任务。时间片长度必须是时钟中断周期的倍数。时间片越短响应时间表现越好，但上下文切换的成本也会影响性能。周转时间表现差。
- `MLFQ`：多级反馈队列，用历史经验预测未来。有许多独立的队列，每个队列有不同的优先级。一个工作只能存在于一个队列中，总是先执行较高队列中的工作。每个队列有多个工作，具有相同优先级，这些工作才有轮转调度。根据观察到的每个工作的行为调整优先级，如果一个工作长时间占用CPU，会降低优先级，在进程运行中学习其行为，预测未来行为。规则：
  - 规则1：若A的优先级>B，运行A；
  - 规则2：若A的优先级=B，轮转运行A和B；
  - 规则3：工作进入系统时，放在最高优先级；
  - 规则4a：工作用完整个时间片后，降低优先级；
  - 规则4b：若工作在其时间片内主动释放CPU，优先级不变；
  - 规则4：优化CPU计时方式，记录一个进程在某一层中消耗的总时间，而不是调度时重新计时。工作用完某一层的时间配额，无论中间主动放弃多少次CPU，就降低其优先级；
  - 规则5：为避免饥饿问题，经过一段时间S，将所有工作重新加入到最高优先级队列。
- 比例份额调度：利用了随机，按照每个工作的权重，确保每个工作获得一定比例的CPU时间，主要应用于虚拟机。
- 多处理器调度：



## 虚拟化内存

每个进程访问自己的私有虚拟地址空间，操作系统以某种方式映射到机器的物理内存上。一个进程的地址空间包含运行的程序的所有内存状态，包括代码、栈和堆。虚拟化内存的三个目标：

- 透明：程序不应该感知到内存虚拟化，好像拥有自己的私有物理内存，操作系统让不同的工作复用内存；
- 效率：高效实现虚拟化，包括时间和空间；
- 保护：进程只能访问自己的内存空间，不受其他进程影响；
- 灵活：程序能以任何方式访问自己的地址空间，让系统更容易编程；

内存主要分类：

- 栈：申请和释放由编译器隐式管理，又称自动内存，只存函数调用的信息。
- 堆：申请释放操作显式完成。

内存API：

- `malloc`：传入要申请的堆内存大小，返回指向新空间的指针。
- `free`：释放堆内存。
- `mmap`：在程序中创建一个匿名内存区域，该区域不与任何特定文件关联，而是与交换空间关联。

### 地址转换

地址转换可看成是受限直接执行方式的补充。硬件对每次内存访问进行处理，将指令中的虚拟地址转换为数据实际存储的物理地址。操作系统管理内存，记录被占用和空闲的内存位置，保持对内存使用的控制。

#### 动态重定位

动态重定位：每个CPU需要两个硬件寄存器，基址寄存器和界限寄存器。进程中使用的内存引用是虚拟地址，硬件将虚拟地址加上基址寄存器的内容，得到物理地址，发给内存系统。界限寄存器确保地址在进程地址空间范围内，提供了访问保护。

缺点，效率低、浪费空间、容易产生内部碎片。栈和堆之间会有空闲空间。

操作系统需要记录哪些空闲内存没有使用，以便能够为进程分配内存。最简单的数据结构是空闲列表，记录当前没有使用的物理内存的范围。为支持动态重定位，操作系统采取的行动：

- 进程创建时，操作系统为进程的地址空间找到内存空间，将数据结构标记为已用；
- 进程终止时，操作系统回收内存，将内存放回到空闲列表；
- 上下文切换时，因每个CPU只有一个基址寄存器和一个界限寄存器，对每个运行的程序值都不同。切换进程时，操作系统要保存和恢复寄存器，如保存在 `PCB`。
- 必须提供异常处理程序，操作系统启动时加载这些程序，当有进程非法访问内存，触发CPU异常，终止错误进程。
- 地址的转换过程完全由硬件处理，没有操作系统接入。

#### 分段

分段将进程的地址空间分成不同长度的段，一个段是地址空间里的一个连续定长区域，给每个段分配一对寄存器。分段机制使操作系统将不同的段放入不同的物理内存区域，避免虚拟地址空间中未使用的部分占用物理内存。如果访问非法的地址，会陷入操作系统，终止进程。

硬件用段寄存器做地址转换：

- 显式：用虚拟地址的开头几位标识不同的段，剩余部分存储偏移量。
- 隐式：硬件通过地址产生的方式确定段，程序计数器产生在代码段；基于栈或基址指针在栈段；其他在堆段。

为节省内存，可在地址空间之间共享内存段。为支持共享，需要为每个段增加保护位，标识程序能否读写该段，或执行代码。增加了保护位，引用内存除了检查虚拟地址是否越界，还要检查是否允许访问。

为支持将地址空间划分为大量较小的段，需要在内存中保存段表。

#### 分页

分页不是将一个进程的地址空间分割成几个不同长度的逻辑段（代码、堆、栈），而是分割成固定大小的单元，每个单元称为一页。物理内存看成是定长槽块的阵列，叫作页帧，每个页帧包含一个虚拟内存页。

分页最大的优点是灵活性，不管进程如何使用地址空间，栈和堆的增长方向如何。

为记录地址空间的每个虚拟页在物理内存中的位置，会为每个进程保存一个页表，为地址空间的每个虚拟页面保存地址转换。转换虚拟地址需要虚拟页面号和页内偏移量。每个进程的页表存储在内存中。

最简单的页表形式为线性页表，是一个数组。通过虚拟页号检索数组，找到物理帧号。每个页表项的内容包含许多不同的位：

- 有效位：指示特定地址转换是否有效，所有未使用的空间被标记为无效，如果访问这种内存，会终止进程。标为无效的页面不用分配物理帧，可节省大量内存。
- 保护位：表明页是否可读、写或执行。
- 存在位：表示该页是在物理存储器还是在磁盘上。
- 脏位：表示页面在内存中是否被修改过。
- 参考位：用于追踪页是否被访问，确定哪些页的访问频率高。

对每个内存引用，分页需要执行一个额外的内存引用，先从页表获取地址转换，开销很大。

`TLB`，地址转换旁路缓冲存储器，用于缓存虚拟地址到物理地址到转换。每次内存访问，硬件先检查 `TLB`，如果有期望的转换映射，不用访问页表；如果没有，访问页表寻找转换，将转换更新到 `TLB`。`TLB` 的成功依赖于空间和时间局部性：

- 时间局部性：最近访问过的项可能很快会再次访问；
- 空间局部性：程序会访问空间邻近的地址。

当 `TLB` 未命中，有两种处理方式：

- 硬件：硬件通过页表基址寄存器得知页表的位置，遍历页表找到正确项，取出转换映射，更新 `TLB`，再重试该指令。
- 软件：`TLB` 未命中，硬件抛出异常，进入内核模式，由操作系统更新 `TLB` ，再进入用户模式重试该指令。

### 空闲空间管理

空闲列表包含一组元素，记录堆中哪些空间还没有分配。如果请求内存大于连续空间大小，失败；如果请求内存小于连续空间大小，会找到一块可用的空闲空间，将其分割返回，更新空闲列表。当有内存被释放，如果临近的空间空闲，会将它们合并成一个大的空闲内存块。

分配内存时会在 `header` 中保存额外的信息，在返回的内存块之前，包含分配空间的大小，幻数（标记内存类型做完整性检查）。实际释放内存的大小是分配的空间大小加上头块大小。

基本分配策略：

- 最优匹配：遍历空闲列表，找到和请求大小一样或更大的空闲块，返回最小的一块。避免空间浪费，但遍历代价高。
- 最差匹配：找最大的空闲块，分割满足请求，将剩余块加入空闲列表。容易产生过量碎片，开销大。
- 首次匹配：找到第一个足够大的块返回。有速度优势，但容易让空闲列表开头部分有很多小块。一种优化方式是保持空闲块按内存地址有序，使合并更容易，减少内存碎片。
- 下次匹配：多维护一个指针，指向上次查找结束的位置，加速对空闲空间的查找。
- 分离空闲列表：若某应用程序经常申请一种大小的内存空间，就用一个独立的列表。若空闲空间耗尽，再向通用的空闲列表请求。
- 伙伴系统：当有内存请求，递归地将空闲空间一分为二，直到满足请求大小。只允许分配2的整数次幂大小，会有内部碎片。优点是空间释放后很容易合并。

`TLB` 只对当前进程有效，如果发生了进程切换，简单的方式是清空 `TLB`，这样开销比较大。通常在 `TLB` 加个地址空间标识符，`ASID`，可看作 `PID`，比 `PID` 少一位。这样`TLB` 可同时缓存不同进程的地址空间映射，用 `ASID` 区分是哪个进程。

`TLB` 的替换策略：

- `LRU`：最近最少使用，利用内存引用流的局部性，嘉定最近没有用过的项是好的换出候选项。
- `random`：随机选择一项换出去。

页表太大占用过多内存，增加负担。解决方法：

- 增加页大小：缺点是大内存页会导致每页内存的浪费，产生内部碎片。
- 混合方法：结合分段和分页，为每个逻辑分段提供一个页表，对于代码、堆和栈，会有三个页表。基址寄存器保存该段页表的物理地址，界限寄存器指示页表的结尾。确定地址引用哪个段，用地址空间的前两位。缺点还是使用了分段，容易产生外部碎片。
- 多级页表：页表很多项可能是无效的，如何在内存中只保留有效区域？将页表分成页大小的单元，如果整页无效，就不分配该页的页表。页目录存储页表的页位置，及页的有效性。不需要找到连续的空闲物理内存。缺点是，如果 `TLB` 未命中，需要从内存加载两次，才能获取地址转换。如果页目录过大，查找页目录需要较长的时间，可以将页目录拆为多层。
- 反向页表：保留一个页表，一个项代表一个物理页，会记录哪个进程在使用次页，及进程的哪个虚拟页映射到此物理页。搜索该线性表代价比较大，通常会建立哈希表。

### 交换空间

从磁盘取一定区域，将物理内存页放进去，需要的时候交换回去。需要在页表项里增加一个存在位，表示该页是否在物理内存上。访问不在物理内存中的页，会触发页错误。页表的某些位存储硬盘地址，操作系统接收到页错误，从硬盘将页读到内存中，更新存在位。

如果内存满了，需要交换出一些页。操作系统会预留一小部分空间内存，设置高水位线和低水位线，决定何时从内存清除页。物理内存少于低水位线个页可用时，会有交换守护线程释放内存，直到有高水位线个可用的页。

性能优化：把多个要写入的页聚合或分组，同时写入交换空间，提高磁盘效率。交换页时线检查是否有空闲页，如果没有通知交换线程释放，执行完毕唤醒原来的线程，将需要的页交换进内存。

物理内存包含所有页的子集，可看作虚拟内存页的缓存。缓存选择替换策略的目标是让缓存未命中率最少，用平均内存访问时间衡量：

- 最优替换策略：替换内存中在最远将来才会被访问到的页；
- `FIFO` 替换策略：页进入系统时，放入一个队列。发生替换时，从队尾踢出。优点是实现简单，命中率较低；
- 随机替换策略：内存满时随机选择一个页替换。
- `LRU`：替换最近最少使用的页



# 并发

线程类似于独立的进程，只有一点区别：共享地址空间，能访问相同的数据。进程切换把状态保存到进程控制块，线程切换把状态保存到线程控制块，只有一点区别：地址空间不变，不需要切换当前使用的页表。

临界区，访问共享变量的代码片段。如果一个线程在临界区执行，其他线程应被阻止进入临界区。

## 锁

锁是一个变量，需要声明类型。锁变量保存了锁在某一时刻的状态，是否被占用。还可以保存持有锁的线程，请求获取锁的线程队列，这些对锁的调用者不可见。

# 持久性

磁盘不会被虚拟化。操作系统写入磁盘，首先确定数据要驻留在磁盘上的哪个位置，在文件系统维护的各种结构中对其记录。需要向底层存储设备发出IO请求，以读取现有结构或更新它们。为了提高性能，文件系统会延迟写操作一段时间，将其批量分组为较大的组。为处理写入期间系统崩溃，大多数文件系统都包含复杂的写入协议，如日志或写时复制，确保写入序列期间发生故障后可恢复到合理的状态。
