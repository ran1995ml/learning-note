# 内存区域划分

## 程序计数器

一块较小的内存空间，是当前线程执行的字节码的行号指示器。字节码解释器通过改变计数器的值选取下一条需要执行的字节码指令。每个线程都有一个独立的程序计数器。

如果线程执行的是 `Java` 方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果线程执行的是 `Native`
方法，计数器值应为空。该区域是唯一没有规定 `OutOfMemoryError` 情况的区域。

## 虚拟机栈

线程私有，生命周期和线程相同。描述的是 `Java`
方法执行的线程内存模型，每个方法被执行，虚拟机会创建一个栈帧，存储局部变量表、操作数栈、动态连接、方法出口等。每个方法被调用到执行完毕，对应一个栈帧从入栈到出栈的过程。

局部变量表存放了编译期可知的基本数据类型、对象引用，64位的 `long` 和 `double` 会占用两个 `slot`，其余只占一个。局部变量表所需的内存空间在编译期完成分配，进入方法时，该方法需要在栈帧中分配的空间时完全确定的。

如果线程请求栈深度大于虚拟机允许的深度，抛出 `StackOverflowError`；如果虚拟机容量可动态扩展，当栈扩展时无法申请到足够内存会抛出 `OutOfMemoryError`。

## 本地方法栈

和虚拟机栈的区别是，本地方法栈为 `Native` 方法服务。

## 堆

堆是虚拟机管理的最大的一块内存，是所有线程共享的内存区域，虚拟机启动时创建。唯一目的就是存放对象实例，是垃圾收集器管理的内存区域。堆可划分出多个线程私有的分配缓冲区，以提升对象分配时的效率。堆可分配在不连续的物理内存中，逻辑上应是连续的，对于大对象，可能会要求连续的内存空间。设置参数 `-XX:+HeapDumpOnOutOfMemoryError` ，虚拟机可在内存溢出时 `dump` 出当前的内存堆转储快照。如果是内存泄漏，查看对象到 `GC Roots` 的引用链，分析是和哪些 `GC Roots` 关联，才导致垃圾收集器无法回收。

## 方法区

存储虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存。JDK8后，用在本地内存中实现的元空间实现方法区。该区域的内存回收目标主要针对常量池的回收和对类型的卸载。

运行时常量池是方法区的一部分。`Class` 文件除了有类版本、字段、方法、接口等描述信息外，还有一项是常量池表，存放编译期生成的字面量和符号引用，这部分在类加载后放到运行时常量池。运行时常量池具备动态性，运行期间生成的新常量也可以放入池中。

直接内存通过 `-XX:MaxDirectMemorySize` 指定，默认与堆的最大值一致。如果直接内存溢出，明显的特征是 `Heap Dump` 文件没有明显的异常，且文件很小。 

# 对象创建

创建对象使用 `new` 指令，虚拟机遇到 `new` 指令时，先检查该指令的参数能否在常量池定位到该类的符号引用，检查该符号引用代表的类是否被加载、解析、初始化过，如果没有，先加载该类。类加载检查后，为新生对象分配内存。对象所需内存大小在类加载完成即可确定，为对象分配空间会将一块确定大小的内存块从堆中划分出来。

分配方式：

- 指针碰撞：若堆内存是规整的，有一个指针作为已分配区域和空闲区域的分界点，将指针挪动与对象大小相同的距离。
- 空闲列表：若堆内存不规整，虚拟机维护一个列表，记录每个内存块的状态，找出一块足够大的内存分配给对象，更新列表。

选择哪种分配方式由堆是否规整决定，堆是否规整由垃圾收集器是否带有空间压缩整理能力决定。

对象创建不是线程安全的，解决方法：

- 堆分配内存空间的动作进行同步处理，用 `CAS` 加失败重试保证更新操作的原子性；
- 把内存分配的动作按线程划分在不同空间中进行，每个线程在堆中预先分配一小块内存，为本地线程分配缓冲，每个线程在各自的缓冲区分配，缓冲区用完，分配新的缓冲区才同步锁定，用 `-XX: +/-UseTLAB` 开启。

内存分配完成，必须将分配到的内存空间初始化为零值，保证实例字段不赋初始值即可使用。接着将对象的信息存到对象头，如属于哪个类、类的元数据信息、对象的哈希码、`GC` 分代年龄、锁。最后执行构造方法，完成真正的初始化。

# 对象内存布局

一个对象的内存分为三部分：

- 对象头：一部分存储对象自身的运行时数据，如哈希码、`GC` 分代年龄、锁标志、线程持有的锁、偏向线程ID、偏向时间戳。另一部分是类型指针，对象指向它的类型元数据的指针，通过该指针可确定对象是哪个类的实例。如果是数据，需要有一块记录数据长度的数据，普通对象可通过元数据确定大小，但数据必须确定长度。
- 实例数据：对象存储的有效信息，包括从父类继承来的和子类中定义的字段。相同宽度的字段被分配到一起存放，在父类中定义的变量会出现在子类前。
- 对齐填充：起占位符的作用，对象的大小必须是8字节的整数倍。

# 对象访问

通过栈内的 `reference` 操作堆上的具体对象。虚拟机规范只规定了 `reference` 是一个对象引用，具体访问方式由虚拟机来定，主流的两种方式：

- 句柄：堆中会划分出一块内存作为句柄池，`reference` 存储对象的句柄地址，句柄包含了对象实例数据与类型数据的地址信息，好处是对象若被移动，无需修改 `reference`。
- 直接指针：`reference` 存储的是对象地址，好处是访问对象只需一次访问，节省指针定位的时间开销。

# 垃圾收集

## 判断对象存活

判断对象是否存活的算法：

- 引用计数器法：在对象中添加一个引用计数器，每有一处引用该对象，计数器值加一，引用失效，计数器值减一，计数器为0的对象就是不能再被使用的。缺点是不能解决对象间相互循环引用。
- 可达性分析法：通过一系列 `GC Roots` 的根对象作为起始节点集，根据引用关系向下搜索，搜索走过的路径为引用链，若某个对象到 `GC Roots` 间无任何引用链相连，则该对象是不可达的，证明不再被使用。可作为 `GC Roots` 的对象包括：
  - 栈中引用的对象；
  - 方法区中类静态属性引用的对象；
  - 方法区中常量引用的对象；
  - 虚拟机内部的引用，如基本数据类型对应的 `Class` 对象、常驻异常对象和系统类加载器；
  - 被同步锁持有的对象。

引用表示另一块内存的起始地址。引用的分类：

- 强引用：永远不会被回收；
- 软引用：有用非必须的对象，将要内存溢出时才会回收；
- 弱引用：强度比软引用更弱，只能生存到下次垃圾收集发生为止；
- 虚引用：最弱的一种引用关系。设置虚引用是为了在对象被回收时收到通知。

宣告对象死亡，需要经历两次标记过程，如果对象不可达，被第一次标记；如果对象需要执行 `finalize`，会被放在队列中等待执行，在执行过程中与引用链上的对象建立上关联，则被移出回收集合，否则被回收。对象不需要执行 `finalize` ，则直接被回收。

## 方法区回收

主要回收废弃的常量和不再使用的类型。对于常量，如果没有对象引用它，此时发生垃圾回收，则会被移出常量池。在大量反射、动态代理的框架中，才会考虑方法区的卸载，常量废弃需要满足三个条件：

- 该类所有实例都被回收，包括子类实例；
- 加载该类的类加载器被回收；
- 该类对应的 `Class` 对象没有再被引用，无法通过反射访问该类的方法。

## 垃圾收集算法

### 分代收集

分代收集被支撑的理论：绝大多数对象存活很多，熬过多次垃圾收集的对象难以消亡，跨代引用相比同代引用占极少数。分代垃圾收集器将堆划分出不同的区域，将回收对象按年龄分配到不同区域，这样才能实现对不同区域采用不同的算法。

堆一般被分为新生代和老年代。新生代中，每次回收会有大量对象死亡，只留下少量对象晋升到老年代存放。因跨代引用占极少数，不需要扫描整个老年代，只需在新生代建立一个记忆集合，记录老年代的哪块内存有跨代引用，只加载这些到 `GC Roots` 扫描。

### 标记清除算法

首先标记出所有需要回收的对象，标记完成后统一回收掉所有被标记的对象。标记过程就是对象是否属于垃圾的判定过程。关注延迟优先考虑此方法。缺点：执行效率不稳定，随对象数量增长而降低；清除后产生大量内存碎片，导致后续分配对象无法找到连续内存而再一次触发垃圾回收。

### 标记复制算法

将可用内存分成两块，每次只使用一块。每次清理，将存活的对象转移到另一块，只需要移动指针直接一次性清理整个空间。如果内存中大多数对象都是存活的，该算法会产生大量内存复制开销，且需要将可用内存缩小为原来的一半，浪费空间。新生代的对象大多数熬不过第一轮收集，因此不需要按照1:1来划分新生代内存。

优化的策略：将新生代分成一块较大的 `Eden` 空间和两块较小的 `Survivor` 空间，每次分配内存只使用 `Eden` 和其中一块 `Survivor`，直接清理掉 `Eden` 和已使用的那块 `Survivor`。默认 `Eden` 和 `Survivor` 的比例是8:1。如果 `Survivor` 空间不足以容纳一次 `Minor GC` 后存活的对象，这些对象会通过分配担保机制直接进入老年代。

### 标记整理算法

主要用于老年代垃圾回收。标记存活对象后，将所有存活对象都向内存空间一端移动，直接清理掉边界外的内存。移动对象需要停顿工作线程，不移动会影响之后的内存分配，但整体移动会提高吞吐量。

## 根节点枚举

用可达性分析法判断对象存活，需要先找出 `GC Roots`。根节点枚举需要保障一致性快照时才能进行，需要先暂停工作线程，这个过程很快，虚拟机维护了 `OopMap` 数据结构记录对象引用，可快速完成 `GC Roots` 枚举。如果为每条指令都生成对应的 `OopMap`，需要大量额外存储空间。虚拟机只在特定的位置，即安全点生成 `OopMap`，垃圾收集强制要求执行到安全点后才能暂停。安全点通常选在程序长时间执行的地方，如方法调用、循环跳转、异常跳转。

为保证垃圾收集时让所有线程都到最近的安全点停顿，有两种方式：

- 抢占式中断：垃圾收集时，将所有用户线程中断，若有用户线程中断的地方不在安全点，则恢复执行。
- 主动式中断：垃圾收集时，设置一个标识位，线程执行时轮询该标志，发现中断标志为真，会在自己最近的安全点主动中断。

如果到达安全点时，进程没有分配处理器时间，无法响应虚拟机的中断请求，虚拟机也不能持续等待线程。引入安全区域可解决此问题。安全区域是确保在某段代码片段中，引用关系不再变化，在这个区域中任意处执行垃圾收集都是安全的。用户线程执行到安全区域，会标记自己进入了安全区域，虚拟机不必处理已声明进入安全区域的线程。线程离开安全区域时，要检查虚拟机是否完成根节点枚举，完成后线程继续执行，未完成则会等待，直到收到可离开安全区域的信号。

为解决跨代引用，垃圾收集器在新生代建立了数据结构 `RememberedSet`，避免整个老年代加进 `GC Roots` 扫描。记忆集用于记录从非收集区域指向收集区域的指针集合。收集器只需判断某块非收集区域是否存在指向收集区域的指针，不需要了解全部细节。通过写屏障实现更新 `RememberedSet`。写屏障相当于一个 `AOP` 切面，引用类型字段赋值发生前后，会更新 `RememberedSet`。

暂停用户线程是为避免干扰垃圾收集器标记不可达对象。如果用户线程和垃圾收集同时工作，可能导致死亡对象被标记存活、存活对象标记死亡，前者是可容忍的，但后者会导致运行错误。导致对象消失的两个条件：

- 赋值器插入从完全扫描过的存活对象到未访问过的对象的引用；
- 复制器删除了全部从没完全扫描过的对象到未访问过的对象的引用。

解决对象消失，破坏其中一个条件即可，解决方法：

- 增量快照：破坏条件一，当完全扫描过的存活对象插入新的指向未扫描对象的引用时，将该引用记录下来，等扫描结束，再将记录等引用对象作为根，重新扫描一次。
- 原始快照：破坏条件二，当没完全扫描的对象要删除指向未扫描过的对象的引用时，记录要删除的引用，等扫描结束，将记录的引用作为根，重新扫描一次。

这两种方法记录操作都是通过写屏障实现。

## 垃圾收集器

收集器里的并行和并发：

- 并行：同一时间有多条垃圾收集线程同时工作，用户线程处于等待状态；
- 并发：同一时间垃圾收集线程和用户线程都在运行，应用程序处理吞吐量会受一定影响。

衡量垃圾收集器的指标：内存占用、吞吐量、低延迟。

### Serial (Old)

单线程工作，垃圾收集时必须暂停其他所有工作线程直到收集结束。`Serial` 用于新生代垃圾回收，用标记复制算法，优点是简单高效，内存消耗最少，对客户端模式下运行的虚拟机是一个很好的选择。`Serial Old` 用于老年代垃圾回收，用标记整理算法，作为 `CMS` 失败时的后备方案。

### ParNew

是 `Serial` 的多线程版本，主要运行在服务端模式下的虚拟机，主要用于新生代垃圾回收，经常和 `CMS` 配合使用。限制垃圾收集的线程数可用参数 `-XX:ParallelGCThreads`。

### Parallel Scavenge (Old)

新生代垃圾收集器，用标记复制算法。目标是可达到一个可控制的吞吐量，高吞吐量可最高效率使用资源。

```
吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 运行垃圾收集时间）
```

`-XX:MaxGCPauseMillis` 控制最大垃圾收集停顿时间，`-XX:MaxTimeRatio` 设置吞吐量，`-XX:+UseAdaptiveSizePolicy` 开启自适应调节策略。

`Parallel Old` 是老年代版本，支持并发收集，用标记整理算法实现。

### CMS

以获取最短回收停顿时间为目标，用于关注响应速度的应用，用标记清除算法实现。步骤：

- 初始标记：标记 `GC Roots` 能直接关联到的对象，速度很快；
- 并发标记：从 `GC Roots` 的直接关联对象开始，遍历整个对象图，耗时较长但不用停顿线程；
- 重新标记：修正并发标记期间发生的引用变化；
- 并发清除：清理掉判断死亡的对象。

对处理器资源敏感，因不会暂停工作线程，会降低吞吐量，处理器核心数越少对用户线程影响越大。在并发清除阶段用户线程还在运行，会产生垃圾对象，只能放在下次垃圾回收，需要给用户线程预留足够的内存，对老年代的收集不能等到填满再收集，老年代使用达到68%即被激活，容易产生 `Full GC`，激活比例设的太高又容易出现并发失败，启用后备方案 `Serial Old`，导致停顿时间更长。标记清除算法又容易产生大量内存碎片，给对象分配带来麻烦，导致 `Full GC` 提前触发，`CMS` 提供了参数在执行 `Full GC` 前先合并碎片。

### G1

面向局部收集的设计思路，基于 `Region` 的内存布局形式，面向服务端应用的垃圾收集器，在延迟可控的情况下获得尽可能高的吞吐量。其他的垃圾收集器，收集范围是整个新生代、整个老年代或整个堆。`G1` 面向堆内存任何部分组成 `CollectionSet` 回收，衡量标准不是属于哪个分代，而是哪块内存的垃圾数量最多，收益最大。

`G1` 把堆内存划分成大小相等的 `Region`，每个 `Region` 根据需要用于 `Eden` 空间、`Survivor` 空间或老年代空间，收集器采用不同的策略回收不同的 `Region`。`Region` 有一类特殊的 `Humongous` 区域存储大对象，大小超过一个 `Region` 容量一半的对象判定为大对象。每个 `Region` 大小用参数 `-XX:G1HeapRegionSize` 设定，范围是1~32MB。

`G1` 把 `Region` 作为单次回收的最小单元，每次收集到的内存空间都是 `Region` 大小的整数倍，这样可避免在整个堆垃圾回收。`G1` 会跟踪每个 `Region` 的垃圾堆积的价值大小，价值即回收获得的空间大小及所需时间的经验值。后台会维护一个优先级列表，每次根据用户设定的收集停顿时间 `-XX:MaxGCPauseMillis`，优先回收价值最大的 `Region`。

因 `Region` 数量较多，`G1` 至少耗费堆10%～20%的额外内存做垃圾回收。 

存在的问题解决方法：

- 跨 `Region` 引用对象：使用 `RememberSet` 避免全堆作为 `GC Roots` 扫描，每个 `Region` 都维护自己的 `RememberSet`，记录别的 `Region` 指向自己的指针，本质是一个哈希表。
- 保证垃圾收集线程和用户线程互不干扰：通过原始快照实现，为每个 `Region` 设置两个 `TAMS` 指针，`Region` 的一部分空间划出来用于并发回收过程中的新对象分配，新分配的对象地址要在 `TAMS` 指针之上，这样会默认该地址以上的对象存活，不纳入回收范围。如果内存回收赶不上内存分配，会暂停用户线程，导致 `Full GC`。

垃圾收集过程会记录每个 `Region` 的回收耗时、`RememberSet` 数量等统计数据。运行步骤：

- 初始标记：标记 `GC Roots` 直接关联的对象，修改 `TAMS` 指针值，保证用户线程之后在可用的 `Region` 中分配对象。需停顿线程，耗时很短。
- 并发标记：从 `GC Roots` 开始对对象进行可达性分析，找出要回收的对象，可与用户线程并发执行。
- 最终标记：短暂暂停线程，处理并发阶段产生的引用变化；
- 筛选回收：更新 `Region` 统计数据，对每个 `Region` 的回收成本价值排序，根据用户期望的停顿时间制定回收计划，把要回收的 `Region` 里的存活对象复制到空的 `Region`，清理掉整个旧 `Region`，需要暂停用户线程，多条线程并行完成。

从 `G1` 开始，设计导向变为能应付应用的内存分配速率，而不是一次把堆全部清理干净。整体基于标记整理算法，从局部基于标记复制算法，不会产生内存碎片。相比 `CMS`，弱项是用户程序运行过程中，垃圾回收产生的内存占用和额外执行负载较高。

